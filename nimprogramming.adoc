= Computer Programming with the Nim Programming Language
A gentle Introduction
(C) Dr. Stefan Salewski 2020
//v0.1, 21-MAY-2020
:doctype: book
:toc: left
:icons: font
//:experimental:
:imagesdir: http://ssalewski.de/tmp
:source-highlighter: pygments
:pygments-style: monokai
:stylesheet: nimbook.css

:Wirth: Prof. Niklaus Wirth
:uC: micro-controller
:OOP: Object-Oriented-Programming
:OS: operating system
:proc: procedure
:profus: procedures and functions
:curnim: Nim v1.2
:twocom: two's complement

////

asciidoctor -a stylesheet=asciidoctor.css nimprogramming.adoc

we are using these custom roles for clean semantic markup:

[.new]##
[.term] terminal text
[.user] user input
[.ndef] new unknown entity like stack
[.code] inline source code segment
[.imp] important

We use

<<section title>> for cross references
[[anchor]] for anchors
{nbsp}
+->+ disable replacements

////

[quote]
____
When you are not able to explain it with words, you may have to add pictures.
And when you even do not manage it with pictures, you can still make a video.
____

[.normal]
In the year 1970 {Wirth} invented the [.ndef]#Pascal# programming language to teach
his students the fundamentals of computer programming. While the initial core Pascal
language was designed for teaching purpose only, it was soon expanded by commercial
vendors and got some popularity. Later Wirth presented the language [.ndef]#Modula-2#
with improved syntax and support of modules for larger projects, and the
[.ndef]#Oberon# language family with additional support for [.ndef]#Object Oriented
Programming#.

The [.ndef]#Nim# programming language can be seen in this tradition, as it is
basically an easy language suited for beginners with no prior programming experience,
but at the same time is not restricted in any way. Nim offers all the concepts of
modern and powerful programming languages in combination with high performance and
some sort of universality -- Nim can be used to create programs for tiny microcontrollers as well
as for large desktop apps and web applications.

Most books about programming languages concentrate on the language itself and assume
//that the reader is already familiar with most basic concepts and has already some
that the reader is already familiar with the foundations of computer hardware and already has some
programming experience. This is generally a valid approach, as today most
//people are taught these basics in school. But still there are people who missed this
people are taught this fundamental knowledge, sometimes called [.ndef]#Computer Science# (CS)
in school. But still there are people who missed this
introduction in school for various reasons and decide later that they need some
programming skills, maybe for a technical job. And there may exist some children
that are not satisfied with the introduction to computer science taught at school. So
we have decided to start this book with a short introduction to fundamental
concepts -- most people can skip that part. In part II we explain the basics of
computer programming step by step in a way which should enable even children to learn
independently. Part III will give you an overview of the Nim standard library and
part IV will introduce some useful external packages. Part V will introduce advanced
concepts like [.ndef]#asynchronous operations#, [.ndef]#threading# and
[.ndef]#parallel processing#, and [.ndef]#macros# and [.ndef]#meta-programming#. Nim
macros are very powerful but difficult at first. Part VI may finally present some
advanced examples.

= Part I: Introduction

[.normal]
For using computers and writing computer programs you initially do not have to know
many details. It is basically like driving a car: Although a car is a powerful
and complicated tool, kids generally can drive it after a 3-minute introduction.
Still, good racing drivers generally need a much broader insight into the inner
working of all the technical components, and finally, a lot of practice.

== What is a Computer

A computer is primarily a device which can run computer programs.
// primarily, mainly, first, principally, chiefly, preeminently
// mainly, primarily, principally, mostly, chiefly, essentially
Nearly all computers currently in use, from the tiny ones integrated in
electronic gadgets, to the well known desktop computer (PC), to large and
powerful super computers filling whole rooms, work internally with digital data
only.footnote:[In the past some form of analog computers existed, some worked mechanically,
some used analog voltages or currents as input and output signals. Indeed one important
device which is still very common in analog electronics is the summing amplifier,
which can sum up multiple electric voltages.]
Digital data is basically integer (whole) numbers; we will discuss the term digital
in the next section in more detail.

The most
important part of a digital computer is the [.ndef]#CPU#, the [.ndef]#Central Processing
Unit#. That tiny device is built of digital electronic circuits and can perform very
basic mathematical and logical operations on numbers, like adding two numbers or
deciding if a number is larger or smaller than another number. Most computer CPU's
can only store very few numbers internally, and forget the numbers when the power is
switched off. So the CPU is generally electrically connected to a [.ndef]#RAM#
module, a [.ndef]#Random Access Memory#, which can store many more numbers and allow
fast access to these numbers, and to a [.ndef]#Harddisk# or [.ndef]#SSD# device which
can permanently store the numbers, but does not allow such fast access. The stored
numbers are most often called just [.ndef]#data# -- basically that data is nothing
more than numbers, but it can be interpreted in many different ways, as pictures,
sounds and much more.

Nearly all of today's desktop computers, and even most notebooks and cellphones contain
not only a single CPU, but multiple CPUs, also called "Cores", so they can run different programs
in parallel, or a single program can run parts of it on different CPU's, to
increase performance or reduce total execution time. The so called super
computers can contain thousands of CPU's. Beside CPU's most computers have also
at least one [.ndef]#GPU#, a [.ndef]#Graphic Processing Unit#, that can be used
to display data on a screen or monitor, maybe for doing animations in games or
for playing video. The distinction between CPU and GPU is not really sharp; generally
// for playing video. The distinction between CPU and GPU is not really sharp: generally
a CPU can also display data on screens and monitors, and GPU's can do also
some data processing that CPU's can do. But GPU's are optimized for the
data display task.

More visible to the ordinary computer user are the peripheral devices like
keyboard, mouse, screen and maybe a printer. These enable human
interaction with the computer, but are in no way a core component of it; the computer
can run well without them. In notebook or laptop computers or in cellphones,
the peripheral devices are closely integrated with the core components.
All the physical parts of a computer are also called [.ndef]#hardware#, while
the programs running on that hardware are called [.ndef]#software#.

A less visible but also very important class of computers are [.ndef]#{uC}# and so
called [.ndef]#embedded devices#, tiny pieces with generally a hull of black plastic
with some electrical contacts. The devices generally contain all necessary elements,
that is the CPU, some RAM and a persistent storage that can store programs when no
electric power supply is available. These devices may be restricted in computing
power and the amount of data that they can store and process, but they are contained in
many devices.  They control your washing machine, refrigerator, television and
radio and much more. Some devices in your home may even contain multiple {uC}s and
often the {uC}s can already communicate with each other by RF (Radio-Frequency), or
access by WLAN the internet, which is sometimes called [.ndef]#Internet of Things#
(IoT).

Another class of large and very powerful digital computers are called [.ndef]#mainframe computers# or
[.ndef]#super computers#, which are optimized to process large amount of data very fast. The
key to their gigantic computing power is that many fast CPU's work in parallel -- the problem
or task is split into many small parts that are solved by one CPU each, and the final result
is then the combination of all the solved sub-tasks. Unfortunately it is not always possible
to split large problems into smaller sub-tasks.

Digital computers are generally driven by a clock that pulses at a certain frequency.  
The CPU can do simple operations like the addition of two
integers at each pulse of the clock signal. For more complicated
operations like a multiplication or a division it may need more clock pulses.
//Digital computers are generally driven by a rectangular shaped binary clock signal, that is
//an electrical voltage that jumps continuously from maybe a level of 0 Volt to a level
//of 1 Volt and back. The CPU can do simple operations like the addition of two
//integers for each (upwards) transition of the clock signal, for more complicated
//operations like a multiplication or a division it may need more clock periods.

So a rough measure for the performance of a computer is the clock rate, that
is the number of clock pulses per second, divided
by the number of pulses that the CPU needs to perform a basic operation, multiplied
by the number of CPU's or Cores that the computer can use. 

A totally different kind of computers are [.ndef]#Quantum Computers#, large,
expensive high-tech devices, which use the rules of [.ndef]#quantum mechanics# to
calculate many computations in parallel. Today only a few of them exist, for
research at universities and some large commercial institutes. Quantum computers may
at some time in the future fundamentally change computing and our whole world, but they
are not the topic of this book.

== Analog and Digital

Whenever we measure a quantity based on one tiny base unit, then we
work in the digital area, we measure with some granularity.
Our ordinary money is digital in some way, as the cent is the
smallest base unit; you will never pay a fraction of a cent for something.
Time can be seen as a digital quantity as long as we accepts the second
as the smallest unit.  Even on so called analogue watches the second hand
will generally jump forwards in steps of a second, so you can not
measure fractions of a seconds with that watch.

An obvious analogue property is the thermodynamic temperature and its classic measurement device is the
well known capillary thermometer consisting of a glass capillary
filled with alcohol or liquid mercury. When temperature increases
the liquid in a reservoir expand more than the surrounding glass and partly fills
the capillary.  That filling rate is an analogue measure for the temperature.

// An hourglass usually has sand running through a constriction, so it seems analog to me.  -Jim
// The sand consists of tiny stones, you can count the stones!
While the hourglass
works digitally, the sundial does not.

Most of the quantities in our real world seem analog,
and digital quantities seem to be some sort of arbitrary approximation.
//All the quantities in our real world seems to be not digital or granular,
//so digital quantities seems to be some sort of arbitrary approximation.
But [.ndef]#quantum mechanics# has taught us that many quantities in our world
really have a granularity. Physically quantities like energy or momentum
are indeed multiplies of the tiny [.ndef]#planck constant#. Or consider electric
charge, which is always a multiple of the [.ndef]#elementary charge unit# of one
electron. Whenever an electrical current is flowing through an
electrically conducting wire, an ionized gas or an electrolyte like salt water,
there are flowing multiplies of the elementary charge only, never fractions of
it. And of course light and electromagnetic radiation also has some form of granularity,
which the photoelectric effect as well as compton scattering proves.

// A paragraph usually has more than a single sentence.  -Jim
An important and useful property of digital signals and digital data is
that they map directly to integral numbers.

The simplest form of digital data is binary data, which can have only two
//distinct values, 0 and 1. When you use a mechanical switch to turn
distinct values. When you use a mechanical switch to turn
the light bulb in your house on or of, you change
the binary state of the bulb. And your neighbor, when watching
your house, receives binary signals.footnote:[Well, when we watch very
carefully, we will notice that the signal is not really digital -- when we
switch on, the filament may take a few milliseconds to heat up, and
when we switch off, the filament takes again a few milliseconds to cool down.]

Digital computers are generally using binary electric states internally -- voltage
or current [.term]#on# or [.term]#off#. Such a on/off state is called a bit. We will learn more
about bits and binary logic later. One bit can store obviously only two states, which we may
map to the numbers 0 and 1. Larger integer numbers can be represented by a sequence
of multiple bits.

The [.ndef]#morse code# was an early application to transmit messages encoded in binary form.

// data is usually considered singular in English
// A very important property of digital data is that
// it can be copied and transmitted exactly. The reason for this is that it has
A very important property of digital encoded numbers (data) is that
they can be copied and transmitted exactly. The reason for this is that digital numbers have
a well defined clean state, there is no noise which overlays the data
and may accumulate when the data is copied multiple times. Well, that
// a well defined clean state: there is no noise that may accumulate the data is copied multiple times. Well, that
statement is not really true -- under bad conditions the noise can become so
large that it changes the binary state of signals. Imagine we try to transfer
some whole numbers encoded in binary form, maybe by binary states encoded as voltage
level 0 Volt and 5 Volt, over an electric wire and a long distance.
It is clear that the long wire can pick up some electromagnetic noise that can change the true 0 Volt
data to a voltage that is closer to 5 Volt than to the true 0 Volt level, so it is
received incorrectly. To catch such types of transmission errors [.ndef]#checksums# are added
to the actual data.  A checksum is derived by a special
formula from the original data and transferred with it. The receiver applies the same formula to
the received data and compares the result with the received checksum. If it does
not match, then it is clear that data transmission is corrupted, and a resend is requested.
// I think you should leave the following statement out, or omit the whole paragraph.  -Jim
But the field of data transmission and its error detection is not the topic of this book.

The opposite of digital is generally called analogue, a term which is used for
data which have or seems to have no granularity. For example we speak
of an analogue voltage when the voltage can have each value in a given range
and when the voltage does not "jump" but change continuous.footnote:[Of course
even digital electric signals can not really "jump" from one digital state to another,
but the transition time is much shorter than the time duration of the steady state, so
the signal has a rectangular shape when we watch it on an oscilloscope, it looks
like +__--__--__+.]
For observing analogue voltages or currents one can use a moving coil meter, a device
where the current flows through a coil in a magnetic field and the magnetic
force moves the hand/pointer.

We said in the previous section that nearly all of our current computers
work with digital data only. Basically that is that they work internally with
integer numbers, stored in sequences of binary bits. All input for computers must have the form
of integer numbers, and all output has the form of integer numbers.
Whenever we want to feed computers with some sort of analogue data, like an
analogue voltage, we have to convert it into a digital approximation.
For that task special devices called [.ndef]#analog to digital converters# (ADC)
exists. And in some cases we have to convert the digital output data of
computers to analogue signals, like when a computer plays music: The computer
output in form of digital data is then converted by a device called
[.ndef]#digital to analog converter# (DAC) into an analogue voltage, that generates an
analogue current through a coil in the speakers of our sound box, and that
electric current in the coil generates a magnetic field which exercise
mechanical forces and moves the membrane of the speaker, resulting
in oscillating motions, which generates air pressure variations that our ear
can detect and that we finally hear as sound.

== What is an Operating System

Most computers, from cellphones to large super computers use an [.ndef]#{OS}# (OS).
A well known OS is the GNU/Linux kernel. Operating Systems can be seen
as the initial program that is loaded and started when we switch the computer on and
// if you only have 2 things, separate them with and rather than comma.  -Jim
that works as some kind of supervisor: it can load other programs and it distributes resources
like CPU cores or RAM between multiple running programs. It also:
// I would make this a list.  -Jim
// no list as this enumeration is not really that important and as we do NOT explain the
// list items later in detail
controls user
input by keyboard and mouse, displays output data on the screen -- as text
or graphics, controls how data is loaded and stored to nonvolatile storage
media like hard-disk or SSD, manages all the network traffic, and many more tasks.
An important task of the OS is to allow user programs to access all the various
hardware components from different vendors in a uniform high level manner.
An OS can be seen as an intermediate layer between user programs like
a text processor or a game, and the hardware of the computer.
The OS allows user programs to work on a higher level of abstraction, so they do
not need to know much about the low level hardware details.

Current Linux kernel version 5.6 has 28 million lines of source code!

Small {uC}s and embedded devices often do not need to use an
{OS}, as they generally run only one single user program and
because they usually do not have a large variety of hardware components to support.

== What is Computer Programming

Computer programming includes the creation, testing and optimizing of computer
programs.

== What is a Computer Program

A computer program is basically a sequence of numbers, which make some sense to a
computer CPU, in such a way that it recognizes the numbers as so called
[.ndef]#instructions# or [.ndef]#numeric machine code#, maybe the instruction to add
two numbers.

The first computers, built in the 1950's, were indeed programmed
by feeding sequences of plain numbers to the device. The numbers were stored
on so called [.ndef]#punch cards#, consisting of strong paper where the numbers were
encoded by holes in the cards. The holes could be recognized by electrical contacts to
feed the numbers into the CPU. As plain numbers do not match well human thinking,
soon more abstract codes where used. A very direct code, which matches numerical
instructions to symbols, is the [.ndef]#assembly language#. In that language for
example the character sequence "add A0, $8" may map directly to a sequence of numbers
which instructs the CPU to add the constant integer number 8 to CPU register A0,
where A0 is a storage area in the CPU where numbers can be stored. As there exists
many different types of CPU's all with their own instruction sets, there exists many
different assembly instruction sets, with similar, but not identical instructions. The rules
that describe how these basic instructions have to look are called the
[.ndef]#syntax# of the assembly language.

The numerical machine code or the corresponding assembly language is the most basic
instruction set for a CPU.  Every instruction which a CPU can execute
maps to a well-defined assembly instruction. So each operation that a computer may be
able to perform can be expressed in a sequence of assembly instructions. But
complicated tasks may require millions of assembly instructions, which would take
humans very long to write, and even much longer to modify, proof and
debug.footnote:[The search for the reason why a program does not do exactly what was
hoped for by its creators is called debugging. That term is still a legacy from the
very first computers in the 50's, where logical circuits where built by mechanical
relays, for example a logical [.term]#and# operation was built by two relays in
series connection.  To let the current flow, both of them would have to be in the
//conducting state. And legend has it that sometimes insects walked onto the electric
// "legend has it" -- I have never seen that phrase
conducting state. And it was told that sometimes insects walked onto the electric
contacts of the relays and blocked them. Today, misbehavior of computer programs is
rarely due to hardware faults, but the term "bugs" for errors and "debugging" for finding and
fixing the errors, was kept.]

Just a few years after the invention of the first computers, people recognized
that they would need even more abstract instruction sets, like repeated execution,
//composed conditionals, or data types other than plain integer numbers as operands. So
// sound strange!
composed conditionals, or other data types than plain integer numbers as operands. So
higher level programming languages like Algol, Fortran, C, Pascal or Basic where
created.

//Simple C program here, with its assembly code from godbolt.org.

== What is an Algorithm?

//An [.ndef]#algorithm# is a detailed sequence of abstract instructions to
An [.ndef]#algorithm# is a detailed sequence of more or less abstract instructions to
solve a specific task or to reach a goal. Cooking recipe books and car repair instructions
are examples of algorithms. The basic math operations kids learn in school to add,
multiply or divide two numbers with paper and pencil are algorithms too. Even
starting a car follows an algorithm -- when the temperature is below zero and snow covers
the vehicle, than you first have to clean the windows and lights. And when you first
drive again after a longer break you would have to check the tires before you start
// if you have two complete sentences, separate them with ; not with comma  -Jim
// the engine. Algorithms can be carried out by strictly following the instructions without
// needing to really understand how and why it works.
the engine. Algorithm can be carried out by strictly following the instructions -- it
is not necessary to really understand how and why it works.

So an algorithm is a perfect fit for a computer, as computers are really good at
following instructions without really understanding what they are trying to accomplish.

A math algorithm to sum up the first 100 natural numbers may look like

[source]
----
use two integer variables called i and sum
assign the value 0 to both variables

while i is less than 100 do:
  increase i by one
  add value of i to sum

optionally print the final value of sum
----

== What is a Programming Language?

Most traditional programming languages were created to map algorithms to elementary
CPU instructions. Algorithms generally contain nested conditionals, repetition, math
operations, recovery from errors and maybe plausibility checks. Complicated
algorithm generally can be split into various logical parts, which may include reading
in data, multiple processing steps, and storing or displaying data as plain text,
graphic or animation. This splitting into parts is mapped to programming languages
by grouping tasks into subroutines, functions or procedures
which accept a set of input parameters and can return a result. As algorithms often
work not only with numbers, but also with text, it makes sense to have a
form of textual data type in a programming language too. And all the data types can be
grouped in various ways, for example as sequences of multiple data of the same type,
like lists of numbers or names. Or as collections of different types, like name, age
// and profession of a citizen in an income tax database. programming languages provide
// support for all of these use cases.
and profession of a citizen in an income tax database. For all these use cases
programming languages provide some sort of support.

== Compilers and Interpreters

We already learned that the CPU in the computer can execute only simple instructions,
which we call numeric machine code or assembly instructions.

To run a program written in a high level language with many abstractions
we need some sort of converter to transfer that program to the basic
instructions that the CPU can execute. For the conversion process
we have basically two options: We can convert the whole program
into machine code, store it to disk, and than run it on the CPU. Or we can convert it
in small portions, maybe line by line, and run each portion whenever
we have converted it. Tools that convert the whole program first, are called
compilers. [.ndef]#Compilers# process the program that we have written, 
include other source code like needed library modules, check the code
//compilers. [.ndef]#Compilers# process the program that we have written and when necessary
//also other source code like needed library modules, check the code
for obvious errors and then generate and store the machine code that we then can run.
Tools that process the source code in small portions, like single statements,
are called [.ndef]#interpreters#. They read in a line of source code, investigate it
to check if it is a valid statement, and then feed the CPU with corresponding instructions
to execute it. It is similar to picking strawberries: you can pick one
and eat it at once, or you can put them all into a basket and eat them later.
Both interpreters and compilers have advantages and disadvantages for special use cases.
//Compilers can detect errors before the program is run, and compiled
Compilers can already detect errors before the program is run, and compiled
//programs generally run fast, as all the instructions are available when
programs generally run fast, as all the instructions are already available when
the programs runs. The compiling step takes some time of course, at least a few
seconds, but for some languages and large programs it may take much longer. That
can make the software development process slow because as you add or change code, you have to
compile it before you can execute and test your program. That may be inconvenient
for unskilled programmers as they may have to do much testing. Some use a programming
style that is: change a tiny bit of the source code, then run it and see what is does.
But a more common practice is that you think about the problem first and then write the
code, that then in most cases does nearly that what you intended. For this style of
programming you do not have to compile and execute your code that often. Compilers
have one important benefit: they can detect many bugs, mostly typing errors,
already in the compile phase, and they give you a detailed error message. Interpreters
have the advantage that you can modify your code and immediately execute it without delay. That is
nice for learning a new language and for some fast tests, but even simple
typing errors can only be detected when they are encoutered while running the program. If your test
does not try to run a faulty statement, there will be no error, but it may occur later.  Generally
interpreted program execution is much slower than running compiled executables,
as the interpreter has to continually process the source code, while the
compiler does it only once before the program is run. At the end of this section a few additional notes:
Compilers are sometimes supported by so called linkers. In that case the compiler
converts the source code, that can be stored in multiple text files, each in a
sequence of machine code instructions, and finally the linker joins all these
//converts the source code, perhaps stored in multiple text files, to a
//sequence of machine code instructions for each, and finally the linker joins all these
machine code files to the final executable. Some compilers do not need the
linking step or call the linker automatically. And some interpreters
convert the textual source code in one very fast, initial pre-processing step ("on the fly")
to so called byte code, that can then be interpreted faster. The Ruby and Python do that.
// languages do that.
// I think for Java you are talking about a JIT compile.  Python and Ruby also use virtual machines.  -Jim
// True, later we will discuss details, JIT would be confusing here.
Some languages like Java can compile and optimize the source code while the
program is running. For that process a so called virtual machine is used, that
builds an intermediate layer between the hardware and the user program.

// I would either add a question mark below or change to Types of Programming Languages  -J
== What type of Programming Languages exist

We already mentioned the assembly languages, which provide only the basic operations
that the CPU can perform. Assembly languages provide no abstractions, so maybe we should
not even call them programming languages at all. Then there are low level languages like
Fortran or C, with some basic abstractions and higher data types which still work
close to the hardware and are mostly designed for high performance but not to detect
and prevent programming errors or to make life easy for programmers.
//In addition to
//integer numbers, these languages provide: real numbers, called "floating point"
//in computer jargon; text or "character strings"; and collections of data or "arrays".
// I added the above sentence because below talks about typing, but no other data
// types have ever been introduced.  -J
// I think that is too much detail here -- and assembly langauge can support float as well.

A different approach is taken by languages like Python or Ruby, which try to make
writing code easier by offering many high level abstractions and which have
better protection against errors, but are not as efficient.

Another way to differentiate programming languages is if they are statically or
dynamically typed. Ruby and Python are two examples of dynamically typed languages,
that is, they use variables which can store any data type, and the variable's type 
can change during program execution. That seems
comfortable for the user, and sometimes it is, especially for short programs which
may be written for one-time use only and are sometimes called scripts. But dynamic
typing makes discovery of logical errors harder -- an illegal addition
of a number to a letter may be detected only at runtime.  And
dynamically typed languages generally waste a lot of memory and their performance is
not that great.
//It is as you would own many moving boxes and you store all
//your goods in it, each piece in one box.
//I removed the moving box analogy because it didn't seem to relate well to typing.
//I guess if you said there were "hat boxes", "shoe boxes", "dish boxes" and so on,
//and compared that to variables having integer, real, or character type, it might work.  -J
// Moving boxes are really not a bad example as how dynamically typed languages store variables.
For statically typed languages each variable
has a well defined data type like integer number, real number, a single letter, a
text element and many more. The data type is assigned by the author of the program with
a type declaration or
is detected by the compiler when processing the program source code, called type inference,
and the variable's type does not change during the compile. In this way the compiler can check for
logical errors early in the compile process, and the compiler can reserve memory blocks
exactly customized to the variables that we want to store, so total memory
consumption and performance can be optimized.
//The terms compiler, interpreter,
//compile-time and runtime are explained in the next section.

All these types of programming languages are often called imperative programming
languages, as the program describes detailed what to do. There are other types of
programming languages too, for example languages like Prolog, which try to give only a set
of rules and then let the computer try to solve a problem with these rules. And
of course there are the new concepts of [.ndef]#artificial intelligence# (AI) and machine
learning, which are less based on algorithms and more on neural nets which are trained
with a lot of data until it provides the desired results. Nim, the computer language
this book is about, is an imperative language,
so we will focus on the imperative programming style in this book. But of
course Nim can be used to create AI applications.

//This section is a little confusing to me.  I see 4 cases:
//1. Compiles to machine code directly (C, C++, Rust, D, Julia (I think), etc)
//2. Translated to another language, then compiled (Nim (to C), Scala (to Java)
//3. Translated to a VM language, then run by a VM (Python)
//4. Translated to a VM language, then JIT'ed during execution (Java)
// Yes, it is confusing and the distiction is not sharp.
// At least initially Julia compiled not to native machine code. But
// now many languages try to generate native machine code, this includes
// Python, Kotlin, maybe Julia. I dont think that Scala compiles to Java.
Further, we differentiate between languages like C, C++, Rust, Nim and many more that
can run directly on the hardware of the computer, languages like Java, Scala, Julia and
some more that use a large [.ndef]#Virtual Machine# (VM) as an intermediate layer between the
program and the hardware, and interpreted languages like Ruby and Python. Languages
using a virtual machine generally need some startup time when a program is invoked,
as the VM must be loaded and initialized, and interpreted languages are generally not
very fast.footnote:[Exactly speaking Ruby and Python do not really interpret the
source code, but compile it on the fly to byte-code, which is then interpreted. And
there exists some variants of Ruby and Python that compile with some success to
native machine code. Crystal is a variant of Ruby, with some significant differences
that compiles to fast native machine code.]

An important class of programming languages are the so called [.ndef]#{OOP}# (OOP) languages,
which become popular in the 1990's. For some time
it was assumed that {OOP} was the ultimate solution to manage and structure really
large programs. Java was the most prominent example of the OOP languages. Java
forces the programmer to use OOP design, and languages like C++, Python or Ruby
strongly push programmer to use OPP design. Practice has shown that OOP design is not
the ultimate solution for all computing problems, and OPP design may prevent optimal
performance. So newer languages like Go, Rust and Nim support some form of OOP
programming, but use it only as one paradigm among many other.

Another popular and important class of programming languages is JavaScript and its
more modern cousins like TypeScript, Kotlin or Dart and others. JavaScript was
designed to run in web browsers to support interactive web pages and programs and
games running in the browser. In this way the program became nearly independent from
the native operating system of the computer. Note that unlike the name may indicate,
JavaScript is not closely related to the Java language.
Nim can compile to a JavaScript backend, so it supports web development well.

== Why Nim

NOTE: In this section we are using a lot of new Computer Science (CS) expressions but do not explain them.
That is intentional -- when you already know them you may get a better feeling of what
Nim is, and when you do not know them you will at least learn that we can describe
Nim with fancy-sounding terms.

Three well known traditional programming languages are C, Java and Python. C is
//When a group of words are used together as 1 adjective to describe a noun, the
//group of words is hypenated because together they are 1 adjective for 1 noun.
//Or you could put them in quotes, like "close to the hardware" language.  -J
basically a simple, close-to-the-hardware language created in 1972, for which
compilers can generate fast, highly optimized native machine code, but it has cryptic
syntax, some strange semantics, and is missing higher concepts of modern languages.
Java, created in 1995, forces you strongly to the object-orientated style of programming
(OOP) and runs on a virtual machine, which makes it unsuitable for embedded systems and
{uC}s. Python, created in 1991, is generally interpreted instead of
compiled, which makes program execution not very fast, and it does not really
allow writing low level code which operates close to the hardware. Of course there
are many more programming languages, each with its own advantages and
disadvantages, with some optimized for special use cases.

//state-of-the-art is usually hyphenated, because of the rule I mentioned above.
//the same with Python-like syntax.  -J
Nim is a state-of-the-art programming language well suited for systems and
application programming. Its clean Python-like syntax makes programming easy and fun
for beginners, without applying any restrictions to experienced systems programmers.
Nim combines successful concepts from mature languages like Python, Ada and Modula
with a few established features of the latest research. It offers high performance with
type and memory safety while keeping the source code short and readable. The
compiler itself and the generated executables support all major platforms including
Windows, Linux, BSD and Mac OS X. The custom package manager, Nimble, makes use and
redistribution of programs and libraries easy and secure. Nim supports various
"backends" to generate the final code.  The C and LLVM-based backends allow easy OS library calls without
additional glue code, while the JavaScript backend generates high quality code for
web applications. The integrated "Read/Eval/Print Loop" (REPL), "Hot code reloading",
incremental compilation, and support of various development environments including
debugging and language server protocols makes working with Nim productive and
enjoyable.

=== Nim is Efficient

Nim is a compiled and statically-typed language. While for interpreted, dynamically-typed
languages like Python we have to run every statement to check even for trivial
errors, the Nim compiler checks for most errors during the compile process. The
static typing together with the well-designed Nim type system allows the compiler to
catch most errors already in the compile phase, like the undefined addition of a
number and a letter, and report the errors in the terminal window or directly in the
editor or IDE. When no errors are found or all errors have been fixed, then the
compiler generates highly optimized dependency free executables. And this compilation
process is generally really fast, for example the compiler compiles itself in maybe
10 to 30 seconds on a typical modern PC.

Modern concepts like zero-overhead iterators, compile-time evaluation of user-defined
functions and cross-module inlining in combination with the preference of
value-based, stack-located data types leads to extremely efficient code.
Multi-threading, asynchronous input/output operations (async IO), parallel processing and SIMD instructions
including GPU execution are supported.
Various memory management strategies exists: selectable and tuneable high performance
[.ndef]#Garbage Collectors# (GC), including a new fully deterministic destructor based GC, are
supported for automatic memory management. These can be disabled for manual memory management.  This makes Nim a good
choice for application development and close to the hardware system programming at
the same time. The unrestricted hardware access, small executables and optional GC
will make Nim a perfect solution for embedded systems, hardware driver and (OS)
development.
//Sorry, I didn't realize that (OS) expanded an abbreviation!  -J

=== Nim is Expressive and Elegant

Nim offers a modern type system with templates, generics and type inference. Built-in
advanced data types like dynamic containers, sets, and strings with full UTF
support are completed by a large collection of library types like hash tables and
regular expressions. While the traditional {OOP} style with
inheritance is supported, Nim does not enforce this programming paradigm and offers
modern concepts like procedural and functional programming. The powerful AST-based
hygienic macro system offers nearly unlimited possibilities for the advanced
programmer. These macro and meta-programming system allows compiler-guided
code generation at compile time, so the Nim core language can be kept small
and compact, while many advanced features are enabled by user defined macros. For
example the support of asynchronous IO operations has been created with these forms of
meta-programming, as well as many Domain Specific Language extensions.

=== Nim is Open and Free

The Nim compiler and all of the standard library are implemented in Nim. All source
code is available under the less restricted MIT license.

=== Nim has a friendly and helpful growing community

The Nim forum is hosted at

https://forum.nim-lang.org/

and the software running the forum is coded in Nim.

Real-time chat is supported by IRC, Gitter and others.

=== Nim has a encouraging future

Started more than 10 years ago as a small community project of some bright CS
students led by [.ndef]#Mr. A. Rumpf#, it is now considered as one of the most interesting and promising
programming languages supported by uncounted individuals and companies of leading
computer industry, for instance in the areas of game, web and crypto-currency development.
Nim has made large progress in the last few years: it reached version 1.2 with some
stability guaranties and a new deterministic memory management system was introduced,
which will improve support of parallel processing and the use of Nim in the embedded area.

== Why is Nim not a popular mainstream language yet?

Nim was created by Mr. A. Rumpf in 2008, supported by a few volunteers. Finally in
2018 Nim got some significant monetary support by [.ndef]#Status Corp.# and in 2019 stable Nim
version 1.0 was released. But still Nim is developed by a small core team and some
volunteers, while some other languages like Java, C#, Go or Rust are supported by large
companies, or like C and C++ have a very long history and well-trained users. And
finally there are many competing languages, some with a longer history, and some
maybe better suited for special purposes, like JavaScript, Dart or Kotlin for Web
development, Julia or R for numeric applications, or C and Assembly for the tiny 8-bit
{uC}s with a small amount of RAM.

Nim is already supported by more than 1000 external packages which cover many
application areas, but that number is still small compared to really popular
languages like Python, Java or JavaScript. And some Nim packages can currently not
really compare with the libraries of other languages, which have been optimized for years
by hundreds or thousands of full-time developers.

Indeed the future of Nim is not really secure. Core developers may vanish,
financial support may stop, or maybe a better language may appear. But even
if the development of Nim should stop some day, you will still be able to use
it, and many concepts that you may have learned with Nim can be used with other
modern languages too.

//In most of these headings, I think each word should be capitalized (except and, or, the, of)
== Some Facts About Nim

* The generated executables are dependence free and small: a simple
chess program with a plain GTK-based graphical user interface is only 100 kB in size and
the size of the Nim compiler executable itself is about 5 MB. It is possible to shrink the executable
size of "Hello World" programs to about 10 kB for use on tiny {uC}s.
//with the Nim runtime using about 5 MB. It is possible to shrink the executable
//size to about 10 kB for use on tiny {uC}s.

* Nim is fast. Generally performance is very close to other
high-performance languages such as C or C++. There are some exceptions still: other
languages may have libraries or applications that have been tuned for performance for many
years, while similar Nim applications are so far less tuned for performance, or maybe
are more written with a priority of short and clean code or runtime safety.

* Clean syntax with significant whitespace, no need for block delimiters like
[.term]#{}# 
or [.term]#begin/end# keywords, and no need for statement delimiters like [.term]#;#

* Safety: Nim program are type- and memory-safe -- memory corruption is prevented by the
compiler as long as unsafe low level constructs like cast and the addr operator are not used.

* Fast compiler. The Nim compiler can compile itself and other medium-size packages
in less
than 10 seconds, and upcoming incremental compilation will increase that speed
further.

* Nim is statically typed: each object and each variable has a well-defined type,
which catches most programming errors already at compile time, prevents runtime
errors, and ensures highest performance.

* Nim supports various memory management strategies, includeing manually
allocations for critical low-level tasks as well as various garbage collectors
including a state-of-the-art, fully deterministic memory manager.

* Nim produces native, highly optimized executables and can also generate
JavaScript output for web applications.

* Nim has a clean module concept which helps to structure large projects.

* Nim has a well-designed library which supports many basic programming tasks.
The full source code of the library is included and can be viewed easily
from within the HTML-based API documentation.

* That library is supported by more than 1000 external packages for a broad range
of use cases.

* Asynchronous operation, threading and parallel processing is supported.

* Nim supports all popular operating systems like Linux, Windows, MacOS and Android.

* Usage of external libraries written in C is easy and and occurs directly
without any glue code, and Nim can even work together with code written in other
languages, for example there are some Nim +<->+ Python interfaces available.
//I would mention these by name: nimby, etc

* Many popular editors have support for Nim syntax highlighting and other
IDE functionality like on-the-fly checking for errors and displaying detailed
information.

== Our first Nim Program

To keep our motivation, we will present a first tiny Nim program now. Actually we
should have delayed this section until we have installed the Nim compiler on our
computer, but we can already run and test the program by just copying it into one
of the available Nim online playgrounds like

https://play.nim-lang.org/

In the section <<What is an Algorithm>> we described an algorithm to sum up the first 100 natural
numbers. Converting that algorithm into a Nim program is straightforward and results
in the text file below. You can copy it into the playground and run it now if you
want. The program is built using some elementary Nim instructions for which we will give
only a very short description here. Everything is explained in much more detail in the
next part of this book.

[source,nim]
----
var sum: int
var i: int
sum = 0
i = 0
while i < 100:
  inc(i, 1)
  inc(sum, i)
echo sum
----

We write Nim programs in the form of plain
text files, and you will learn how to create them soon. We call these
text files the [.ndef]#source code# of the program.  The source code is the input for the
compiler. The compiler processes the source code, checks it for obvious errors and
then generates an executable file, which contains the final CPU
instructions and can be run. Executable files are sometimes called executables
or binary files. The term binary is misleading, as all files on computers are indeed
stored as binary data, but the expression "binary" is used to differentiate
the executable program from text files like the Nim source code which we can
read, print and edit in an editor. Don't try to load the executable files generated by the Nim
compiler into a text editor, as the content is not plain text, but numeric machine code
that may confuse the editor. On the Windows OS, executable files generally get a special name extension
[.term]#.exe#, but on Linux no special name extensions are used.

One elementary entity of computer programs is a
variable, which is basically a named storage area in the computer. As Nim is a
compiled and statically-typed language, we have to declare each variable before we
can use it. We do that by choosing a meaningful name for the variable and specifying
its data type. To tell the compiler about our intention to declare a variable, we
start the line with the [.term]#var# keyword, followed by the chosen name, a colon
and the data type of our variable. The first line of our program declares a new
variable named sum of datatype int. Int is short for integer and indicates that our
variable should be able to store negative or positive integer numbers. The
//I am taking out so called in many places because it is out of place in most less-formal English writing.  -J
[.term]#var# at the start of the line is a [ndef]#keyword#. Keywords are
reserved symbols which have a special meaning for the compiler. Var indicates
that we want to introduce a new variable.  The compiler will recognize that and will
reserve a memory location in the RAM of the computer which can store the actual value
of the variable.
//I would try to figure out a way to highlight Nim keywords  -J

The second line is nearly identical to the first line: we declare another variable
again with int type and plain name i. Variable names like i, j, k are often used when
we have no idea for a meaningful name and when we intend to use that variable as a
counter in a loop.

In line 3 and 4 of our program we initialize the variables, that is, we give them a
well-defined initial value. To do that we use the [.term]#=# operator to assign it a
value. Operators are special symbols like [.term]#+#, [.term]#-#, [.term]#*# or [.term]#/#
to indicate our desire to do an
//if a word starts with a vowel, like addition, use an before it; otherwise use a  -J
addition, a subtraction, a multiplication or a division. Note that the [.term]#=#
operator is used in Nim like in many other programming languages for assignment, and
not like in traditional mathematics as an equality test. The reason for that is that in
computer programming, assignments occur more often than equality tests. Some early
languages like Pascal use the compound [.term]#:=# operator for assignment, which
may be closer to mathematics use, but is more difficult to type on a keyboard and
looks not too nice for most people. An expression like [.term]#x = y# assigns
//if you want to abbreviate "that is", you can use ie.  eg is the abbreviate of "for example",
//though many English readers do not know the difference!  -J
the content of variable y to x, that is, x gets the value of y, the former value of x
is overwritten and lost, and the content of y remains unchanged. After that assignment,
x and y contain the same value. In the above example we do not assign the content of
a variable to the destination, but instead use literal constant with value 0. When the computer
has executed lines 3 and 4 the variables sum and i each contain the start value 0.

Line 5 is much more interesting: it contains a [.term]#while# condition. The line
starts with the term [.term]#while#, which is again a reserved keyword, followed by
the logical expression [.term]#i < 100# and a colon. An expression in Nim is
something which has a result, like a math expression as [.term]#2 + 2# which has the
result 4 of type integer. A logical expression has no numerical result, but a
logical one, which can be [.term]#true# or [.term]#false#. The logical expression
[.term]#i < 100# depends on the actual content of variable [.term]#i#. The two lines
following the line with the [.term]#while# keyword are each indented by two spaces,
meaning that these lines start with two spaces more than the line before. That
form of indentation is used in Nim to indicate blocks. Blocks are grouped statements.
The complete while loop consists of the line containing the while keyword followed
by a block of statements. The block after the while condition is executed as long as
the [.term]#while# condition evaluates to true. For the first iteration [.term]#i#
has the initial value [.term]#0#, the condition [.term]#i < 100# evaluates to
[.term]#true# and the block after the [.term]#while# condition is executed for the
first time. In the following block we have the [.term]#inc()# instruction.
[.term]#inc# is short for increment. [.term]#inc(a, b)# increases the value of a by
b, b is unchanged. So in the above block [.term]#i# is increased by one, and after that [.term]#sum#
is increased by the current value of [.term]#i#. So when that block is executed for
the first time [.term]#i# has the value [.term]#1# and [.term]#sum# also has the
value [.term]#1#. At the end of that block execution starts again at the line with
the [.term]#while# condition, now testing the expression [.term]#i < 100# with
[.term]#i# containing the value [.term]#1# now. Again it evaluates to [.term]#true#,
the block is executed again, [.term]#i# gets the new value [.term]#2#, and
[.term]#sum# gets the value [.term]#3#. This process continues until [.term]#i# has
the value [.term]#100#, so the condition [.term]#i < 100# evaluates to [.term]#false#
and execution proceeds with the first instruction after the [.term]#while# block.
That instruction is an [.term]#echo# statement, which is used in Nim to write values
to the terminal or screen of the computer. Some other languages use the term
[.term]#print# or [.term]#put# instead of [.term]#echo#.

Don't worry if you have not understood much of this short explanation, we will
explain all that in much more detail later.

== Binary Numbers

When we write numbers in ordinary life we generally use the decimal system with
base 10 and the
10 available digits 0, 1, ... 9.
To get the value of a decimal number we multiply each digit with powers of 10
depending on the position of the digit and sum the individual terms.
A literal decimal number like 7382 has then the numerical
value [.term]#2 * 10^0 + 8 * 10^1 + 3 * 10^2 + 7 * 10^3#. We have used here the
exponential operator [.term]#^# -- with [.term]#10^3 = 10 * 10 * 10#. Current
computers use binary representation internally for numbers. Generally we do
not care much about that fact, but it is good to know some facts about binary
numbers. Binary numbers work nearly identically to decimal numbers.  The
distinction is that we have only two available digits, which we write as
[.term]#0# and [.term]#1#. A number in binary representation is a sequence of these
two digits. Like in the decimal system, the numerical value results from the
individual digits and their position: The binary number [.term]#1010# has the
numerical value [.term]#0 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3#, which is 9 in decimal
notation. For binary numbers the base is 2, so we multiply the binary digits
by powers of two.
Formally addition of two binary numbers works like we know it from the decimal
//Addition of two binary numbers works like the decimal
system: we add the matching digits and take carry into account: [.term]#1001 + 1101 = 11010#
because we start by adding the two least significant digits of each number, which are
both 1. That addition 1+1 results in a carry and result 0. The next two digits are
both zero, but we have to take the carry from the former operation into account, so
result is 1. For the next position we have to add 0 and 1, which is just 1 without a
carry. And finally we have 1 + 1, which results in 0 with a carry. The carry
//maybe it is intentional, but an example with two 1's and a carry would be useful I think,
//because they probably won't know what to do with a 3.  -J
generates one more digit, and we are done. In the decimal system with base 10 a
multiplication with 10 is easily calculated by just shifting all digits one place to
the left and writing a 0 at the now empty rightmost position. For binary numbers it
is very similar: a multiplication by the base, which is two in the binary system,
is just a shift left, with the rightmost position getting digit 0.

In the binary system we call the digits often [.ndef]#bits#, and we number the bits from right
to left, starting with 0 for the rightmost bit -- we say that the binary number
//since "eight" starts with a vowel (aeiou), use an instead of a
10010101 is an 8-bit number because writing that number in binary representation needs
8 digits. Often we imagine the individual bits as small bulbs, a 1 bit is imagined as a
lit bulb, and a 0 bit is imagined as a dark bulb. For lit bulbs we say also that the
bit is set, meaning that in the binary number 10010101, bits 0, 2, 4 and 7 are set, and the
other bits are unset or cleared.

Groups of 8 bits are called a [.ndef]#byte#, and sometimes 4 bits are
called a [.ndef]#nibble#.

Two, four or 8 bytes are sometimes called a [.ndef]#word#, where a word is an entity
which the computer can process in one single instruction. When we have a CPU with 8
byte word size this means that the computer can for example add two variables, each 8
byte in size, in one single instruction.

Let us investigate some basic properties of binary numbers. Let us assume that we have
an 8-bit word. An 8-bit word can have 2^8 different states, as each bit can be set or
unset independently from the other bits. That corresponds to numbers 0 up to 255 --
we assume that we work with positive numbers only for now, we will come to negative
numbers soon. An important property of binary numbers is the wrapping around, which
is a consequence of the fact that we have only a limited set of bits available to store the
number. So when we continuously add 1 to a number, at some point all bits are set,
which corresponds to the largest number that can be stored with that number of bits.
When we then add again 1, we get an overflow. The runtime system may catch that
overflow, so we get an overflow error, or the number is just reset to zero, as it may
happen in our car when we manage to drive one million miles, or when the ordinary
clock jumps from 23:59 to 00:00 of the next day. An useful property of binary numbers
is the fact that we can easily invert all bits, that is replace set bits by unset
ones and vice versa. Let us use the prefix [.term]#!# to indicate the operation of
bit inversion, then [.term]#!01001100# is [.term]#10110011#. It is an obvious and
useful fact that for each number x we get a number with all bits set when we add x
and !x. That is [.term]#x + !x = 11111111# when we consider a 8 bit word. And when we
ignore overflow, then it follows that [.term]#x + !x + 1 = 0# for each number x. That
is a useful property, which we can use when we consider negative numbers.

Now let us investigate how we can encode negative numbers in binary form. In the
binary representation we have only two states available, 0 or 1, a set bit or an
//may is usually used for permission: May I go?  Could/can is used for alternate possibilities
unset bit. But we have no unitary minus sign. We could encode the sign of a number
in the topmost bit of a word -- when the topmost bit is set that indicates that the
number is regarded negative. Generally a modified version of this encoding is used,
called [.ndef]#{twocom}#: a negative number is constructed by first inverting all the
bits -- a 0 bit is transferred into a 1 bit and vice versa -- and finally the number 1
is added. That encoding simplifies the CPU construction, as subtraction can be replaced by
addition in this way:

Consider the case that we want to do a subtraction of two binary encoded numbers.  The
operation has the symbolic notation A - B for arbitrary numbers A and B. The
subtraction is by definition the inverse operation of the addition, that is A + B - B
= A for each number A and B, or in other words, B - B = 0 for each number B.

Assume we have a CPU that can do additions and that can invert all the bits of a
number. Can we do subtraction with that CPU? Indeed we can. Remember the fact that
for each number X [.term]#X + !X + 1 = 0# as long as we ignore overflow. If that
relation is true for each number, than it is obviously true for each B in the
expression A - B, and we can write A - B = A + (B + !B + 1) - B = A + (!B + 1) when
we use the fact that in mathematics addition and subtraction is associative, that is
we can group the terms as we want. But the term in the parenthesis is just the
{twocom}, which we get when we invert all bits of B and add 1. So to do a
subtraction we have to invert the bits of B, and then add A and !B and 1 ignoring
overflow. That may sound complicated, but bit inversion is a very cheap operation in
a CPU, which is always available, and adding 1 is also a very simple operation. The
advantage is that we do not need separate hardware for the subtraction operation.
Generally subtraction in this way is not slower than addition because the bit
inversion and the addition of 1 can be performed at the same time in the CPU as an
ordinary addition.

// this is usually called two's-complement, not two-complement  -J 
From the equation above indicating A - B = A + (!B + 1) it is obvious that we
consider the two-complement (!B + 1) as the negative of B. Note that the
{twocom} of zero is again zero, and {twocom} of 00000001 is 11111111. All
negative numbers in this system have a bit set to 1 at the leftmost position. This
restrict all positive numbers to all the bit combinations where the leftmost bit is
unset. For an 8-bit word this means that positive numbers are restricted to the bits
00000000 to 01111111, which is the range 0 to 127 in decimal notation. The {twocom}
of decimal 127 is 10000001. Seems to be fine so far, but note there exists also the
bit pattern 10000000 which is -128 in decimal.
For that bit pattern there exists no positive value.  If we try to build the
{twocom} of that bit pattern, we would get the same pattern again.
This is an asymmetry of
{twocom} representation, which can not be avoided. It generally is no problem,
with one exception. We can never invert the sign of the smallest available integer;
that operation would result in a runtime error.footnote:[If you have a piece of
paper and a pencil at hand, you may test some properties of signed binary numbers
represented in {twocom}: take binary 0, apply the {twocom} operation
to get the negative of it. Note, we ignore overflow here when we add the 1! That was
easy. Can we verify that all negative numbers in {twocom} can really be
identified by its set topmost bit? Maybe that fact is not really obvious, as we not
only invert all bits of the positive number, but also add 1. OK, let us consider
the non-negative numbers 0 .. 127 for an 8-bit word. All those bit patterns have the topmost bit
cleared and all bit combinations used in the other 7 bits. Inverting these patterns
gives us a pattern with the leftmost bit set and again all bit combinations used in the other 7 bits.
Fine so far, the topmost bit is set, but we still have to add 1 to complete
our {twocom} operation. But the only case where adding 1 changes the topmost
bit is when the 7 other bits are all set, and that is only the case when the initial
value before bit inversion was zero. So the leftmost bit remains set for all
numbers except initial zero, and zero maps to zero again!]

Summary: when we work only with positive numbers, we can store in an 8-bit word,
which is generally called a byte, numbers from 0 up to 255. In a 16-bit word we could
store values from 0 up to 2^16 - 1, which is 65535. When we need numbers which can be
also negative we have for 8-bit words the range from -128 to 127 available, which is
-2^7 up to 2^7 - 1. For a signed 16-bit word the range would be -2^15 up to 2^15 - 1.

While we can work with 8 or 16-bit words, for PC programming the CPU usually supports
32 or 64 bit words, so we have a much larger number range available. But
when we program {uC}s or embedded devices we may indeed have only 8 or 16-bits words
available, or we may use such small words size intentionally on a PC to fit all of our data
into a smaller memory area.

One important note at the end of this section: whenever we have a word with a
specific bit pattern stored in the memory of our computer, then we can not decide
from the bit pattern directly what type of data it is. It can be a positive or a
negative number, but maybe it is not a number at all but a letter or maybe
something totally different. As an example consider this 8 bit word: 10000001. It could
// 10000000 is unsigned 128, right?  I think 10000000 might be a better example, because
// it is 128 as uint8 as -128 as int8
be 129 if we have stored intentionally positive numbers in that storage location, or
could be -127 if we intentionally stored a negative value. Or it could be not a
number at all. Is that a problem? No it is not as long as we use a programming
language like Nim which use static typing. Whenever we are using variables we
declare their type first, and so the compiler can do bookkeeping about the type of
each variable stored in the computer memory. The benefit is, that we can
use all the available bits to encode our actual data, and we do not have to reserve a few
bits to encode the actual data type of variables. For languages without static
typing that is not the case.  In languages like Python or Ruby we can use variables
without a static type, so we can assign whatever we want to it. That seems to be
comfortable at first, but can be confusing when we write larger programs and the
Python or Ruby interpreter has to do all the bookkeeping at runtime, which is slow
and wastes memory for the bookkeeping.
// my experience is the bookeeping is a lot of memory.  Python uses 24 bytes to 
// store a single integer

To say it again in other words: for deciding if an operation is valid, it is
generally sufficient to know the data type of the operands only. We do not have to know the
actual content. The only exception is if we invert the sign of the most negative integer number
or if we do a operation with causes an overflow, as there are not enough bits available
to store the result -- we get a runtime error for that case.
In a statically-typed language each variable has a well-defined type,
and the compiler can ensure at compile time that all operations on that variables are
valid. If a operation is not valid then the compiler will give an error message.
Then when these operations are executed at runtime they are always valid operations,
and the actual content, like the actual numeric value, does not matter.

== Installation of the Compiler

We will not describe in too much detail how you can install the Nim compiler, because that
strongly depends on your operating system, and because the install instructions may
change in the future. We assume that you have a computer with an installed operating
system and internet access, and you are able to do at least very basic operations
with your computer, such as switching it on and opening a web browser or a terminal
window. If that is not the case then you really should ask someone for help for this
basic step, and maybe for some more help for other basic tasks.

Detailed installation instructions are available on the Nim internet homepage at
https://nim-lang.org/install.html. Try to follow those instructions, and when they are
not sufficient, then please ask at the Nim forum for help:
https://forum.nim-lang.org/

If you are using a Linux operating system, then your system generally provides a
package manager, which should make the installation very easy.

For example for a Gentoo Linux system you would open a root terminal and simple type
"emerge -av nim". That command would install Nim including all necessary dependencies
for you. It may take a few minutes as Gentoo compiles all packages fresh from
source code, but then you are done. Similar commands exist for most other
Linux distributions.

Another solution, which is preferable when you want to ensure that you get the most
recent Nim compiler, is compiling directly from the latest git sources. That process is
also easy and is described here: https://github.com/nim-lang/Nim. But before you can
follow those instructions you have to ensure that the git software
and a working C compiler is available on your computer. 

== Creation of Source Code Files

Nim source code, as most source code of other programming languages, is based on text
files. Text files are documents saved on your computer that contain only ordinary
letters which you can type on your keyboard. No images or videos, no HTML content
with fancy CSS styling. Generally source code should contain only ordinary ASCII
text, that is no umlauts or unicode characters.

To create source code we generally use a text editor, which is a tool designed for
creating and modifying of plain text files. If you do not have a text editor yet
you may also use a word processor for writing some source code, but then you have to
ensure that the file is finally saved as plain ASCII text. Editors generally support
syntax highlighting, that is keywords, numbers and such are displayed with a unique
color or style to make it easier to recognize the content. Some editors support
advanced features like checking for errors while you type the program source code.

A list of recommended editors is available at https://nim-lang.org/faq.html

If you do not want to use a special editor now, then for Linux gedit or at least [.term]#nano#
should be available. For Windows maybe something like notepad.

Generally we store our Nim code files in its own directory, that is a separate section
of your harddisk. If you work on Linux in a terminal window, then you can type

----
cd
mkdir mynimfiles
cd mynimfiles
gedit test.nim
----

You type these commands in the terminal window and press the [.term]#return# key
after each of the above lines -- that is you type [.term]#cd# and then press the
[.term]#return# key to execute that command. The same for the next three commands.
What you have done is this: you go to your default working area (home directory),
then create a subarea named mynimfiles, then you go into that subarea and finally you
launch the gedit editor -- the argument test.nim tells gedit that you want to create
a new file called test.nim. If gedit is not available, or if you work on a computer
without a graphical user interface, then you may replace the gedit command by nano.
While gedit opens a new window with a graphical interface, nano opens only a very
simple interface in the current terminal. An interesting editor without a
GUI is vim or neovim. That is a very powerful editor, but it is difficult to learn and it is a bit
strange as you have a command mode and an ordinary text input mode available.
For neovim there is very good Nim support available.

If you do not want to work from a terminal, or if you are using Windows or MAC OS,
then you should have a graphical user interface which enables you also to create a
directory and to launch an editor.

When the editor is opened, you can type in the Nim source code from our previous
example and save it to a file named test.nim. Then you can terminate the editor.

Note that the [.term]#return# key behaves differently in editors than in the terminal window:
In the terminal window you type in a command and finally press the return key to
"launch" or execute the command. In an editor the return key is not that special:
if you press ordinary keys in your editor, than that key is inserted and the cursor
moves one position to the right. And when you press the return key then an
invisible newline character is inserted and the cursor moves to the start
of the next line.

== Launching the compiler and running the program

If you are working from a Linux terminal then you can type

----
ls -lt
cat test.nim
----

That is you first show the content of your directory and then display the content
that you just have typed in.

Now type

----
nim c test.nim
----

That invokes the Nim compiler and instructs it to compile your source code.

The compiler should display nearly immediately a success message. If it displays
some error messages instead, then you launch gedit or nano again, fix your typing
error, save the modified file and call the compiler again.

Finally, when the source text is successfully compiled, you can run your program by
typing

----
./test
----

In your terminal window you seen a number now, which is the sum of the numbers 1 to
100.

If you have not managed to open a terminal where you can invoke the compiler -- well
maybe then you should install some of the advanced editors like VS-Code. They should
be able to launch the compiler and run the program from within the editor directly.

= Part II: The Basics

In this part we will introduce the most important constructs of the Nim programming language,
like statements and expression, conditional and repeated execution, functions and
procedures, iterators, templates, exceptions and we will discuss various basic data types
including the basic container types array, sequence and string.

== Declarations

We can declare constants, variables, procedures or our custom data types. Declarations are used
to give information to the compiler, for example about the type of a variable that we
intend to use.

//a comma cannot be used between two complete sentences.  A semicolon can be used
//between two sentences, but this is not that common, and if done a lot, it starts
//to look/feel "weird" to the reader. -J
We will explain type and procedure declarations in later sections. Currently only constant and
variable declarations are important.

A constant declaration in its simplest form maps a symbolic name to a value, like

----
const Pi = 3.1415
----

//I changed from used (past tense) to use (present tense) because later you used
//assign (present) instead of assigned (past), and using present tense is more
//"active" for the reader I think. -J
We use the reserved word [.term]#const# to tell the compiler that we want to declare
a constant which we have named Pi and we assign it the numeric decimal value 3.1415. Nim has
a small set of reserved words like [.term]#var, const, proc, while# and others, to
tell the compiler that we want to declare a variable, a constant, a procedure or that
we want to use a while loop for some repeated execution. The [.term]#=# is the
assignment operator in Nim, it assigns the value or expression on the right side of
it to the symbol on the left. You have to understand that it is different from the
equal sign we may use in mathematics. Some languages like Pascal initially used
the compound operator [.term]#:=# for assignments, but that is not easy to type on
the keyboard and looks a bit angry for sensible people. And source code usually
contains a lot of assignments, so use of [.term]#=# makes some sense. We
call [.term]#=# an operator. Operators are symbols which perform some basic
operation, like [.term]#+# for the addition of two numbers, or [.term]#=# for the
assignment of a value to a symbol. 

With the above constant declaration we can use the symbol [.term]#Pi# in our program and
don't have to remember or retype the exact sequence of digits. For constants like our Pi value the compiler will
do a substitution in the source code when the program is compiled, so where we
write the symbol [.term]#Pi# the actual numeric value is used.

For constant declarations it must be possible to determine its value at compile time.
Expressions assigned to constants can contain simple operations like basic math, but
some functions calls may be not allowed.

Variable declarations are more complicated, as we ask the compiler to reserve a named
storage location for us:

----
var velocity: int
----

Here we put the reserved keyword [.term]#var# at the beginning of the line to tell the
compiler that we want to declare a variable, then we give our chosen name for that
variable followed by a colon and the data type of the variable. The int type is a
predefined numeric type indicating a signed integer type. The storage capacity of an
integer variable depends on the operating system of your computer. On 32-bit systems
32 bits are used, and on 64-bit systems 64 bits are used to store one single integer variable.
That is enough for even
large signed integer numbers: the range is -2^31 up to 2^31 - 1 for 32 bit systems and
-2^63 up to 2^63 - 1 for 64-bit systems.

For variables we generally use lower case names, but names of constants
may start with an upper case letter.

== Statements

Statements or instructions are a core component of Nim programs: they tell the
computer what it shall do. Often statements are procedure calls, like the
call of the [.term]#echo()# or [.term]#inc()# procedure which we have already seen in part I of the book.
What procedures exactly are we will learn in later sections. For now we just regard
procedures as entities that perform a well defined task for us when we call them. We
call them by writing their name in our source file, optionally followed by a list of
parameters, also called arguments. When we write [.term]#echo 7# then echo is the procedure which we
call, and 7 is the argument, an integer literal in this case. The effect of our
procedure call is that the decimal number 7 is written to the terminal when we run
the program after compilation. A special form of procedures are functions, that are
procedures that can return a value or result. In mathematics, sin() or cos() would be
functions -- we pass an angle as argument and get the sine or cosine as a result.

// the common use of regard is how you feel about a person, and it is a
// somewhat a formal word not used very often  -J
Let's look at this minimal Nim program:

----
var a: int
a = 2 + 3
echo a
----

The Nim program above consists of a variable declaration and two statements: in the
first line we declare the variable we want to use. In the next line we assign
the value [.term]#2 + 3# to it, and finally in line 3 we use the procedure [.term]#echo()# to display the
content of our variable in the terminal window.

Nim programs are generally processed from top to bottom by the compiler, and when we
execute the program after successful compilation, then it also executes from top to
button. A consequence of this is that we have to write the lines of above program
exactly in that order. If we moved the variable declaration down, then the
compiler would complain about an undeclared variable because the variable is 
used before it has been declared. If we exchanged lines 2 and 3, then the
compiler would be still satisfied, and we would be able to compile and run the
program. But we would get a very different result, because we would first try to
display the value of variable a, and later assign a value to it.

// it's called section here, but block in the next paragraph.  I think block is
// probably better since you may later want to say "in this while block, blah blah"  -J
When we have to declare multiple constants or variables, then we can use a block,
that is we write the keyword var or const on its own line, followed by the
actual declarations like in

----
const
  Pi = 3.1415
  Year = 2020
var
  sum: int
  age: int
----

Note the indentation -- the lines after const and var start with some space
characters, so they build a block which allows the compiler to detect where the
declaration ends. Generally we use two spaces for each level of indentation.
Other numbers would work also, but the indentation scheme should be consistent. Two
spaces is the general recommendation, as it is clearly recognizable for humans in the
source code, and because it doesn't waste too much space, that is, it would not generate
long lines which may not fit onto the screen.

Also note that in Nim we generally write each statement onto its own line The line
break indicates to the compiler that the statement has ended. There are a few
exceptions -- long mathematical expressions can continue on the next line (see the
Nim manual for details). We can also put multiple statements on a single line when we
separate them by a semicolon.

We can also declare multiple variables of the same type in one single declaration, like

----
var
  sum, age: int
----

or we can assign an initial start value to a variable like in

----
var
  year: int = 1900
----

Finally, for variable declarations we can use type inference when we assign an initial
start value, that is we can write

----
var
  year = 1900
----

The compiler recognizes in this case that we assign an integer literal to that
variable and so silently gives the variable the int type for us. Type inference can be
comfortable, but may make it harder for readers to understand the code, or the type
inference may not always do exactly what we want. For example in the above code year
gets the type int, which is a signed 4 or 8 byte number. But maybe we would prefer an
unsigned number, or a number which occupies only two bytes in memory. So use
type inference with some caution.

Note: For integral data we mostly use the int data type in Nim, which is a signed
type with 4 or 8-byte size. It usually does not make sense to use many different
integral types -- signed, unsigned, and types of different byte size. Mixing
them in numerical expressions can be confusing and maybe even decrease performance,
because the computer may have to do type conversion before it can do the math
operation. For unsigned types, another problem is that math operations on unsigned
operands could have a negative result. Consider:

----
var a, b: unsigned int
a = 3
b = 7
a = a - b
----

The true result would be -4, but a is of unsigned type and can never contain a
negative content. So what should happen -- an incorrect result or a program termination?

Related to variable declarations is the initial start value of variables. Nim clears
for us all the bits of our variables when we declare them, that is, numbers get always
the initial start value zero if we do not assign a different value in the variable declaration.

In this declaration

----
var
  a: int = 0
  b: int
----

both variables get the initial value zero.

There exists a variant for variable declarations which uses the let keyword instead
of var keyword. Let is used when we need a variable which only once gets a value
assigned, while var is used when we want to change the content of the variable during
program execution. Let seems to be similar to const, but in const declarations we can
use only values that are known at compile time. Let allows us to assign to variables values
that are only available at program run time, maybe because the value is a
result of a prior calculation. But let indicates at the same time that the assignment
occurs only once, the content does not change later.
We say that the variable is immutable.
Use of the let keyword may help the human reader
of the source code understanding what in going on, and it may also help the compiler
doing optimizations to get faster or more compact code. For now we can just ignore
let declarations and use var instead -- later we may use let where appropriate, and the
compiler will tell us when let will not work and we have to use var.

With what we have learned in this section we can rewrite our initial Nim
example from part I in this form:

[source,nim]
----
const
  Max = 100
var
  sum, i: int
while i < Max:
  inc(i)
  inc(sum, i)
echo sum
----

We declared both variables of type int in a single line and
used the fact that the compiler will initialize them with 0 for us.
And we used a named constant for the upper loop boundary. Another
tiny fix is that we wrote [.term]#inc(i)# instead of [.term]#inc(i, 1)#. We could do that
because there exists multiple procedures with the name [.term]#inc()# -- one
which takes two arguments, and one which takes only one argument and
always increases that argument by one. Instead of [.term]#inc(i)# we could have
written also [.term]#i = i + 1# and instead of [.term]#inc(sum, i)# we could write [.term]#sum = sum + i#.
That would generate identical code in the executable, so we can use whatever
we like better.

== Input and Output

We have already used the echo procedure for displaying output in the terminal. For
our experiments we may want to have some user input also. As we do not know much
about procedures currently, let us keep things simple for now and read in a textual user
input from the terminal window.
We use a procedure with name [.term]#readLine()# for this task.

[source,nim]
----
echo "enter some text"
var mytext = readLine(stdin)
echo "you entered:", mytext
----

Note that you have to press the [.term]#return# key after you have entered your text.

The
first line of our program is not really necessary; we just print some message. In the
second line we use the [.term]#readLine()# procedure to read textual user input. The
readLine() procedure needs one parameter to know from where it should read -- from the
terminal window or from a file for example. [.term]#stdin# indicates that it should read
from the current terminal window. Finally in line 3 we use again the [.term]#echo()# procedure to
print some text. In this case we pass two arguments to [.term]#echo()#, a literal text
enclosed in quotes, and then separated by a comma, the [.term]#mytext# variable. The
[.term]#mytext# variable has the data type [.term]#string#. We used type inference in
this example to declare that type: the [.term]#readLine()# procedure always returns a
[.term]#string#, the compiler knows that, so our [.term]#mytext# variable is
automatically declared with type [.term]#string#. We will learn more about data type
[.term]#string# and other useful predefined data types in the next section.

== Data types

=== Integer types

We have already used the [.term]#int# data type, which indicates a signed integer
type of 4 or 8-byte size, depending on the {OS}. The reason the
type depends on the word size of the OS will become clear later when we explain what
references and pointers are.

Beside the int data type, Nim has some more data types for signed and unsigned
integers: [.term]#int8#, [.term]#int16#, [.term]#int32# and [.term]#int64# are signed types with
well-defined bit and word size, and [.term]#uint8#, [.term]#uint16#, [.term]#uint32# and [.term]#uint64# are
the unsigned equivalents. The number at the end of the type name is the bit size; we
get the byte size when we devide that value by 8. Additional we have the type
[.term]#uint#, which corresponds to [.term]#int# and has same size, but stores unsigned
numbers only. footnote:[When we are using the term "size" here, this means how much
space the type needs in the RAM of the computer. A type of size 4 would occupy 4
bytes of the RAM of your computer.] General we should try to use the int type for all
integral numbers, but sometimes it can make sense to use the other types. For
example, when you have to work with a large collection of numbers, you know that each number is
not very big, and your RAM is not really that large, then you may decide for example
to use [.term]#int16# for all your numbers. Or when you know that your numbers will
be really big and will not fit in a 4 byte integer, then you may use the [.term]#int64#
type to ensure that the numbers fit in that type even when your program is compiled
and executed on a computer with a 32 bit OS.

=== Floating point types

Another important numeric data type is float, for floating point numbers.
Floats are an approximation of real numbers.  They can also store fractions, and are
most often printed in the decimal system with a decimal point, or in scientific
notation with an exponent. Examples for floats are

----
var
  mean = 3.0 / 7.9
  x: float = 12
  y = 1.2E3
----

The variable mean is the result of a float division. If we printed the result
there would be a decimal point and some digits following it. For variable x we specify
the float type explicitly and assign the value 12. We could use type inference
if we assigned 12.0, because the compiler can recognize by the decimal point that
we want a float, not a int. In line 3 we use scientific notation for the float
literal that we assign to y, and the value is [.term]#1.2 * 10^3 = 1200.0#. Literal
values like [.term]#2E3# are also valid float literals -- the value would be
[.term]#2000.0#. But literals with a decimal point and no digits before or after the
// I changed this so the period at the end of the sentence wasn't near the numbers. -J
point -- 1. or .2 -- are not valid.

In Nim float variables occupy 64 bits. Nim has also the data type float64 which is
identical to plain float and float32 which can store only smaller numbers and has
less precision. Floats can store values up to a magnitude of approximately
[.term]#1E308# with a positive or negative sign, and floats have a typical precision
of 16 digits.  That is, when you do a division of two arbitrary floats and print the
result, you will get up to 16 valid digits.

Generally we use floats whenever integers are not sufficient for some reason.
For example when we have to do complicated mathematical operations which include
fractional operands like Pi, or when we have to do divisions and need the
exact fractional value. 

Two important properties of floats are that not all numbers can be represented exactly and
that math operations are not absolutely accurate. When you do an addition like 1.0 +
2.0, the result will not be exactly 3.0, and 1.0 + 2.0 - 3.0 will not be exactly zero,
but a tiny floating point number. Maybe in the case when you use the above literal
values the compiler may be able to recognize the expression and deliver the exact
value, but when you assign the literals to variables and then do the math, you can be
sure that it is not absolutely accurate. That is no real problem: the accuracy is in
most cases much better than needed. But you should know about the minimal numeric
errors and should avoid testing two floats for exact equality, because they may not
be equal due to rounding errors, even when in theory the values should exactly match.
Instead of a test for equality sometimes expressions like abs(a - b) < 0.000001 are
used, ie, we take the absolute value of the difference and compare it with a tiny
epsilon. If you ever should use a test like that, think carefully about it --
sometimes it may be better to make an even more complicated test regarding not the
absolute, but the relative difference of the numbers.
// if you are going to mention this, should there be an example?  -J

For floats we have the operators [.term]#+#, [.term]#-#, [.term]#*# and [.term]#/# for addition, subtraction,
multiplication and division. For powers with integral exponents you can use the [.term]#^#
operator, but you have to import it from the math module. [.term]#x ^ 3# is the same as [.term]#x * x
* x#. The math module contains many more functions like [.term]#sin()# or [.term]#cos()#, [.term]#sqrt()# and
[.term]#pow()#. [.term]#sqrt()# is short for square-root, [.term]#pow()# for power, so [.term]#pow(x, y)# is x to the
power of y, when both operands have type float.

=== Boolean types

Boolean types are used to store the result of logic operations. The type is called
bool in Nim and can store only two values, false and true. Although we have
only two distinct states for a boolean variable and so one single bit
would suffice to store a bool, generally a whole byte (8 bits) is used for storing
a boolean variable. Most other programming languages including C do the same. The reason
is that most CPU's can not access single bits in the RAM -- the smallest
entity that can be directly accessed in RAM is a byte.
The default initial state of
a boolean variable is false, corresponding to a byte with all bits cleared.  

----
var
  age = 17
  adult: bool = age > 17
  iLikeNim = true
  iLikeOtherLangaugeBetter = false.
----

In line three we assign to the variable adult the result of a logical comparison. The
next two lines assign the boolean constants [.term]#true# and [.term]#false# to the variables, with their
type [.term]#bool# inferred.

Variables of type [.term]#bool# support the operators [.term]#not#, [.term]#and#, [.term]#or#
and [.term]#xor#. Not inverts the
logic value, [.term]#a and b# is only true when both values are true, and false otherwise. And
[.term]#a or b# is true when at least one of the values is true, and only false when both
values are false. [.term]#xor# is not used that often.  It is called exclusive or, [.term]#a xor b# is
false when both values have the same logic state, that is when both are true, or both
are false. When the values are not the same, than the result of the xor operator is
true.

=== Characters

The data type for single characters is called char in Nim. A variable of type char has 8 bits
and can store single characters. Indeed it stores 8-bit integers which are mapped to
characters. The mapping is described by the ASCII table. For example the integer
value 65 in decimal is mapped to the character A. When we use single character literals,
then we have to enclose the letter in single quotes. As only 8 bits are used to store
characters, we only have 256 different values, including upper and lower case
letters, punctuation characters and some characters with a special meaning like a
newline character to move the cursor in the terminal to the next line, or a backspace
character to move the cursor one position backwards. Single characters are not used
too often since we generally group them in sequences called strings to build text.

The initial ASCII table contains only the characters with numbers 0 up to 127,
here is an overview generated with the small program listed in the appendix:

----
Visible ASCII Characters

      +0   +1   +2   +3   +4   +5   +6   +7   +8   +9  +10  +11  +12  +13  +14  +15  
  0                                                                                 
 16                                                                                 
 32        !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /  
 48   0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?  
 64   @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O  
 80   P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _  
 96   `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o  
112   p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~      
----

The position in the table is the sum of the number on the left and the number
on the top, ie, character A has position 64+1=65, which is the value
the Nim standard function [.term]#ord('A')# or [.term]#int('A')# would return. The characters
with a decimal value less than 32 can not be printed and are called control
characters, like linefeed, carriage return, backspace, audible beep and such.
Character 127 is also not printable, and is called DEL. An important property of
this table is the fact that decimal digits and upper- and lower-case letters
form contiguous blocks. So to test for example if a characters is a uppercase
letter we can use this simple condition: [.term]#+c >= 'A' and c <= 'Z'+#.
// I like to use 'A' <= c and c <= 'Z' -J

Characters with ord() > 127 are so called umlauts, exotic characters of other
languages, and some special characters. But these characters may be different
on different computers, as the characters depend on the active code-page, which
maps position to actual character, and there are multiple code pages.
When we need more than the plain ASCII characters, then we use
strings in Nim, which display many more glyphs by using UTF-8 encoding.   

=== Strings

The string data type is a sequence of characters. It is used whenever a textual input
or output operation is performed. Usually it is a sequence of ASCII-only characters,
but multiple characters in the string can be interpreted as so called utf-8
unicode characters, that allow displaying nearly unlimited symbols as long as all
the needed fonts are installed on your computer and you manage to enter them --
unicode chars may be not accessible by a simple keystroke. For now we will only use
ASCII characters, as they are simpler and work everywhere. String literals must be
enclosed in double quotes. Nim strings are similar to the Nim seq data types: both
are variable-size containers. That means that a string or a seq expands automatically
when you append or insert characters or other strings.

[source, nim]
----
var
  str: string = "Hello"
  name: string
echo "Please tell me your name"
name = readLine(stdin)
add(str, ' ')
echo str, name
----

We declare a variable called str and assign it the initial literal value
[.term]#"Hello"#. We use the [.term]#echo()# procedure to ask the user for his name, and use [.term]#readLine()#
procedure to read the user input from the terminal. To show how we can add
characters to existing string variables we call the [.term]#add()# procedure
to append a space character to our str variable, and finally call the [.term]#echo()# procedure
to print the hello message and the name to the screen. Note that the [.term]#echo()# procedure
automatically terminates each output operation with a jump to the next line. If you
want an output operation without a newline, you can use the similar [.term]#write()#
procedure. But write() needs an additional first parameter, for which we use the
special variable [.term]#stdout# when we want to write to the terminal window.

So we could substitute the last two lines of the above code by

----
write(stdout, str)
write(stdout, ' ')
write(stdout, name)
----

=== Escape sequences in strings

We already learned that the ASCII table contains some special characters. An
important one is the newline character, which moves the cursor in the terminal
window to the beginning of the next line. The [.term]#echo()# procedure prints that character
automatically after each output operation. Indeed it can be important to terminate
each output operation with that character, as the output can be buffered, and writing
just a string without a termination newline may not appear at once on the
screen, but can be delayed. That is bad when the user is asked something and should
respond, but the message is still buffered and not yet visible.

The problem with special characters like backspace or newline is that we can not enter
them directly with the keyboard.footnote:[Well we have a backspace key on our
keyboard, but generally it does not insert a backspace character but deletes the character
to the left of the cursor when we are editing text. And the return key, well,
it indeed inserts a newline character, but at the same time
in our editor the cursor moves to the next line. Most of the
time we desire a character that generates a newline when we run our program,
but not when we enter our source code.] To solve that problem, escape sequences
were introduced for most programming languages. An escape sequence is a special
sequence of characters, that the compiler can discover in strings and then replace
with a single special character. Whenever we want a newline in a string we
type it as [.term]#"\n"#, that is, the backslash character followed by an ordinary
letter n, n for newline. 

----
echo "\n"
echo "Hello\nHello\nHello"
----

The first line prints two empty lines -- two because the [.term]#\n# generates a jump to next
line, and because [.term]#echo()# always adds one more jump to next line. The second line prints
three lines which each contains the word Hello, and the cursor is moved below the
last Hello, because [.term]#echo()# automatically adds one more newline character.

Older Windows versions used generally a sequence of two control characters to start a new line,
one '\r' (carriage-return) to move to the start of the line, and one '\l' (linefeed) to move down. You may still
find these two characters in old Windows text files at the end of each line. Old printers
used these combination too, so it was possible to send that text files to old printers
directly. Nim also has the special escape sequence "\p" which is called platform dependent newline
and maps to  "\c\l" on Windows. That is when we compile our program on Windows, then
the compiler replaces "\p" in our strings with a carriage-return and a linefeed character, and
when we compile on Linux then the compiler replaces "\n" only with a newline character.
But modern Windows supports '\n', so we generally can use that. 

=== Raw strings and multi-line strings

In rare situations you may want to print exactly what you have typed, so you do not
want the compiler to replaces a \n by a newline character. You can do that in two ways:
You can escape the escape character, that is you put in front of the backslash one
more backslash. When you print the string "\\n" you will get a backslash and the n
character in your terminal. Or you can use so called raw strings, that is you put the
character r immediately in front of your string like

----
echo r"\n"
echo "\\n"
----

Multi-line strings are also raw strings, that is contained escape-sequences are not
interpreted by the compiler, and additional multi-line strings, as the name implies,
can extend over multiple lines of the source text. Multi-line texts starts and ends
with three quotes like in

----
echo """this is
three lines
of text"""

echo "this is\nthree lines\nof text"
----

Both echo() commands above generates exactly the same machine code!

=== Comments

Comments are not really a data type, but they are also important. Ordinary comments
starts with the hashtag character # and extend to the end of the line. The #
character itself and all following characters up to the line end are ignored by the
compiler. You can also start the comment with ##, then it is a documentation
comment. It is also ignored by the compiler, but can be processed when you use later
tools to generate documentation for your code. There are also multi-line comments,
which starts with the two characters
+#[+ and ends with +]#+. These form of comment can extend over multiple lines
and can be nested, that is multi-line comments can contain plain or multi-line
comments.

----
# this is comment
## important note for documentation
#[ a longer
but useless comment
#]
----

=== Other data types

There exists some more predefined types like the container types array and seq, which
can contain multiple objects of the same type, or the tuple type which can contain
different types. And we have sets, and enums and finally objects. Nim objects are
similar to C structs, they are not so verbose as Java classes. We will learn more
about all these types in later sections of the book.

== Nim source code

You have already seen a few examples of simple Nim source code. The code is
basically a plain text file consisting of ASCII characters, that is the ordinary
characters which you can type on your keyboard. Generally Nim source code can also
contain unicode utf-8 characters, so instead of using names consisting of ASCII character
for your variable or procedure names, you could just use single unicode characters or
sequences of unicode characters. But generally that makes not much sense, entering
unicode is not that easy with a keyboard, and it is displayed only correctly on the
screen or in the terminal when the editor or terminal supports unicode properly and
when all necessary fonts are installed. That may be the case for your local computer,
but what when someone other may edit your source code?

Nim does currently not allow to insert tabular characters (tabs) in your source code, so you
have to do the indentation of blocks by spaces only.

Names in Nim, as used for variables, constants, procedures, user defined types and
such may contain lower and upper case letters, unicode characters and additional
underscores. But the names are not allowed to start or end with an underscore, and
one underscore may not follow directly after another underscore.

----
var
  leftMargin: int # OK
  next_right_margin: int # OK
  _privat: int # illegal
  custom_: int # illegal
  strange__error: int # illegal
----

Generally we use camel case like leftMargin for names, not snake case like
left_margin.

Current Nim has the special property, that names are case insensitive and that
underscores are simple ignored by the compiler. The only exception is the first
letter of a name, that letter is case sensitive. So the names leftMargin, leftmargin
and left_margin are identical for the compiler. But LeftMargin is different to all
the others, because it starts with a capital letter. This may sound a bit strange at
first, but works well in practice. One advantage is, that a library author may use
snake case in his library for names, but the users of the library can freely decide
if they prefer camelCase. But still you may think that all this generates confusion.
In practice it does not, it prevents confusion. Imagine a conventional programming
language, fully case sensitive and not ignoring underscores: In a larger program we
may then have names like nextIteration and next_Iteration or keymap and keyMap. What
when both names are visible in current scope, and we type the wrong one. The compiler
may not detect it when types match, but the program may do strange things. Nim would
not allow that similar looking names, as the compiler would regard them as identical
and would complain about a name redefinition.

You may ask why the first letter is case sensitive. That is to allow for user defined
types to use capital type names and then write something like [.term]#var myWindow: MyWindow#.
So we can declare a variable named myWindows of a user defined data type named
MyWindow. That is a common practice.

The case insensitivity and the ignoring of underscores may be not the greatest
invention of Nim, but it does not really hurt. The only exception is when we make
bindings to C libraries, where leading or trailing underscores are used, that can
make some renamings necessary.

The only minor disadvantage of Nim's fuzzy names is when you use tools like grep
or your editor search functionality: You could not be sure if a search for "KdTree"
would give you all results, you would have to try "Kd_Tree" or "KDTree" and maybe
some more variants too. For that task Nim provides a tool called nimgrep that
does a case- and style-insensitive search. And maybe your editor supports
that type of search also. You can also enforce a consistent naming scheme
when you call the compiler with the command line argument [.term]#--styleCheck:error#
or [.term]#--styleCheck:hint#.

== Control Structures

The most important control structures of Nim are the if statement for conditional
execution, the related case statement and the while loop for repetitions.

=== If statement and If expression

The if statement with the optional elif and else part evaluates
a sequence of conditions. As soon as one condition evaluates as true the
corresponding statement block is executed, and after that the program
execution continues after the whole if construct. That is at most one
branch is executed. If none of the conditions after the if or elif keywords
evaluates to true, then the else branch is executed if it exists. 

----
if condition1:
  statement1a
  statement1b
  ...
elif condition2:
  statement2a
  statement2b
  ...
elif condition3:
  statement3a
  statement3b
  ...
elsif ...:
  ...
else:
  statementa
  statementb
  ...
----

The most simple form of an if statement is

----
if condition:
  statement
----
----
if age > 17:
  echo "you may drink and smoke, but better avoid it!"
----

Note that the statements are indented by spaces, we use two spaces generally, but
other numbers work as well. And note that it is [.term]#elif#, not elsif like in Ruby, and
that there is a colon after the condition. Instead of a single statement we can use
multiple each, all on its own line and all indented in the same way.

Note: No, the terminating colon is not really necessary for the compiler, the
compiler could determine the end of the condition without it, as the following
statement is indented. But it looks better with colon, the colon makes it for humans
easier to understand the structure of the whole if statement. So the compiler expects the
colons and complains otherwise currently.

We can also have if/else expressions, which returns a value like in

----
var speed: float = if time > 0: delta / time else: 0.0 # prevent div by zero error
----

In C for a similar construct the ternary ? operator is used.

Note that if-expressions must always return a well defined value, so
they must contain an else. A plain if without else, or a if/elsif without an
else does not work. And as Nim is a statically typed language and all
variables have a well defined type, the if-expression must return the same type for
all branches!

----
var a: int
var b: bool
a = if b: 1 elif a > 0: 7 else: 0 # OK
a = if b: 1 elif a > 0: 7 # invalid
a = if b: 1 # invalid
a = if b: 1 else: 0.0 # invalid, different types!
----

=== The Case Statement

The case statement is not used that often, but it can be useful when we have many
similar conditions:

----
case inputChar
of 'x': deleteWord()
of 'v': pastWord()
of 'q', 'e': quitProgram()
else: echo "unknown keycode" 
----

To enable optimizations the case construct has some
restrictions compared to a more flexible if/elif statement:

The variable after the [.term]#case# keyword must have a so called ordinal type like
int, char or string, while float would not work. And the values
after each [.term]#of# keyword must be constant, that is single constant value,
multiple constant values or a constant range like [.term]#'a' .. 'd'# for
the 4 first lower case letters. Of course these constants must have a type
compatible to the type of the variable after the case keyword. A case
statement must cover all possible cases, so most of the time an
else branch is necessary. 

Unless the similar switch statement in C the case statement needs
no break after each branch. If a condition after a [.term]#of# keyword is true, then 
the corresponding statement or statement sequence is executed, and after
that program execution continues after the whole case construct.

The case construct can also be used as an expression like in

----
var j: int
var i: int =
  case j
    of 0 .. 3: 1
    of 4, 5: 2
    of 9: 7
    else: 0
----

Here an else is necessary to cover all cases. And as you see
we can also indent the block after the case keyword if we want.

=== The While Loop

The [.term]#while# loop is used when we want to do conditional repetitions, that is we want to
check a condition and want to execute a block of statements only as long as the
condition is true. If the condition is false in advance or becomes false after some
repetitions then the program execution proceeds after the indented block.

A basic while loop has this shape:

----
while condition:
  statement1
  statementN
firstStatementAfterTheWhileLoop
----

----
var repetitions = 3
while repetitions > 0:
  echo "Nim is easy!"
  repetitions = repetitions - 1
----

That loop would print the message three times. Like the condition in the if clause
the condition is terminated with a colon. Note that the condition must change during
execution of the loop, otherwise, when the condition is true for the first iteration,
it would remain true and the loop would never terminate. We decrease the loop
counter repetitions in the loop, so at some point the condition will become false and
the loop will terminate and program execution will continue with the first statement
after the loop body. Note how we decrement the loop counter: The right site of the
assignment operator is evaluated, after that is done, the new value is assigned to
the counter.

There exists two rarely used variants of a while loop: the loop body can contain a
[.term]#break# or a [.term]#continue# statement, which each consists only of this single keyword. A
break in the body stops execution of the loop immediately and continues execution
after the loop body. And a continue statement in the body skips the following
statements in the body and starts at the top again, the while condition is evaluated
again.

----
var input = ""
while input != "quit":
  input = readLine(stdin)
  if input == "":
    continue
  if input == "exit":
    break
----

Above code used the [.term]#==# and the [.term]#!=# operator. The == operator does a test
for equality, and != test for inequality. Both operator work for
most data types like integer, floats, characters and strings. The
literal value of an empty string is written "". In line 2 we test
if the variable named input has not the value "quit", and in
line 4 we test of that variable is empty, that it contains no text
at all. 

Using of break and continue destroys the expected flow in
loops, it can make understanding loops harder. So we generally avoid their use, but
sometimes break or continue are really helpful. For example when an unexpected error
occurs, maybe by invalid user input.

There in no repeat loop as in Pascal in Nim, which does the first check at the end of
the loop when it was executed already for the first time. Repeat loops are not used
that much in Pascal, and they are some sort of dangerous, because they check the
condition after the first execution of the body, so maybe the body is executed with
invalid data for the first iteration. Later we will see how we can use Nim macros to
extend Nim by a repeat loop that can be used as it would be part of Nim core
functionality.

=== For loops and Iterators

These are very useful and important in Nim and other languages. For loops are most
often used to iterate over containers or collections. We have not discussed the
important array and seq containers yet, but we know already the string container.

A string contains characters, the characters are numbered starting with 0, and we can
access single characters of a string with the subscript operator [.term]#[]# which gets the
position of the desired character as argument. So we could print the single
characters of a string, in this way:

----
var
  s = "Nim is not always that easy?"
  pos = 0
while s[pos] != '?':
  echo "-->", s[pos]
  inc(pos)
----

It is obvious that the pos variable is some sort of annoying here -- we want to
process all the characters in the string in sequence, so why would we have to use a position
variable to do that. And this way is susceptible to errors, maybe we forget
increasing the pos variable in the loop body. So most modern languages provide us
with iterators for this purpose:

----
var
  s = "Nim is not always that easy?"
for ch in items(s):
  echo "-->", ch
----

That is obvious shorter. The for construct may appear a bit strange, and it is
indeed, but it is a common way to write iterators, it is used in Python too. Ruby
uses something like s.each{|ch| ...} instead.

For loops in Nim iterates over containers or collections, and pics each element in
sequence in this process. The variable after the for keyword is used to access or
to reference the single elements. That variable has automatically the right type,
which is the type of the elements in the container, and get in each iteration the
value of the next element in the container, starting by the first element in the
container and stopping when there is no element left. [.term]#Items()# is here the actual
iterator, which allows us to access the individual characters in sequence. It exists
the convention in Nim that an [.term]#items()# iterator is automatically called in a for
construct when no iterator name is explicitly given, so we could also write shorter
[.term]#for ch in s:# in this use case.

You may recognize that the output of the above for loop is not identical to the
output of the previous while loop. The while loops stops when the last char, that is
'?' is reached, while the for loops processes this last character still. That is
intended for the for loop, its general purpose is to process all the elements in
containers or collections.

The above for loop does a read access to the string, that is we get basically a copy
of each character, and we can not modify the actual string in this way. When we want
to modify the string, there is a variant available.

----
var
  s = "Nim is not always that easy?"
for ch in mitems(s):
  if ch == '?':
    ch = '!'
----

Here we use mitems() instead of the plain items(), the leading m stands for mutable.
In the loop body we can assign different values to the actual content.

== Objects

We have worked with basic data types like numbers, characters and strings already.
Often it makes sense to join some variables of these basic data types to more complex
entities. Assume you want to build an online store to sell computers, and you want to
built a database for them. The database should contain the most important data of
each device type, like type of CPU, RAM and SSD size, power consumption,
manufacturer, quantity available, and actual selling price.

We can create a custom object data type with fields containing the desired data for
this purpose:

----
type
  Computer = object
    manufacturer: string
    cpu: string
    powerConsumption: float
    ram: int # GB
    ssd: int # GB
    quantity: int
    price: float
----

We have to use the [.term]#type# keyword to tell the compiler that we want to define a new
custom type.
Writing the type keyword on its own line begins a type section where we can
declare one or more custom data types. All type declarations in a type
section must be indented.
In the next line we write our type name, an equal sign and the keyword
[.term]#object#. That indicates that we want to declare a new object type named Computer.
Here Computer is a type name, in Nim we use the convention that user defined type names start with
a capital letter. In the following indented block we specify the desired fields,
each line contains the name of a field, and a colon followed by the needed data type.
That is similar like a plain variable declaration.

Objects in Nim are similar to structs in C. Unlike classes in Java Nim objects
contain only the fields, sometimes also called member variables, but no procedures,
functions or methods, and no initializers or destructors as in C++. In Nim we keep
the data objects, and the procedures, functions, methods and also optional
initializers and destructors that work with that data objects separated.

Now that we have defined our own new object type, we can declare variables of that
type and store content in its fields.

----
var
  computer: Computer

computer.manufacturer = "bananas"
computer.cpu = "x7"
computer.powerConsumption = 17
computer.ram = 32
computer.ssd = 1024
computer.quantity = 3
computer.price = 499.99
----

Of course in real applications we would fill the fields not in this way, but we would
maybe read the data from a file, from terminal or maybe from a graphical user
interface.

It may look a bit ugly that we have to write [.term]#computer.# before each field when we
access the fields. Indeed in recent Nim versions that is not necessary, you may use
the [.term]#with# construct now instead.

You can use the fields like ordinary variables:

----
computer.quantity = computer.quantity - 1 # we sold one piece
echo computer.quantity
----

As you already know, the right side of the assignment operator is evaluated first,
then the result is stored in the variable on the left side.

Generally a computer store would offer many different types of computers, so it would
make sense to store all the different devices in a container like a sequence, called
short seq in Nim.

== Arrays and Sequences

Sequences and arrays are so called containers, they can contain multiple other
elements, while a plain variable like a float or an int only contains a single value.
We could regard objects also as containers, because objects contain multiple fields,
well maybe. The same holds for tuples -- tuples are a very simple, restricted form
of objects and also contain fields. But more typical container data types are the
built in arrays and sequences, or for example hash tables which are provided by the
Nim standard library. Arrays, sequences and hash tables can contain multiple
elements, but all elements must have the same type.footnote:[But the types can be
sum types, we will discuss them later.] Arrays have a fixed, predefined
size, they can not grow or shrink during runtime of our program. Sequences and hash
tables can grow and shrink.

Arrays and sequences appear very similar, a sequence appears even more powerful
because it can change its size, that is the number of elements that it contains, at
runtime, while an array has a fixed size. So why do we have arrays at all? The reason
is mostly efficiency and performance. An array is a plain block of memory in the RAM
of the computer, which can be accessed very fast and needs not much care by the
runtime system. Sequences take much more effort, especially when we add elements and
the sequence has to grow. When we create sequences, we can specify how many elements
should fit in it at least and the runtime system reserves a block of RAM of the
appropriate size. But when our estimation was too small, and we want to append or
insert even more elements, then the runtime system may have to allocate a larger
block of memory first, copy the already existing elements at the new location, and
then release the old, now unnecessary memory block. And this is an relative slow
operation. The reason why this process can be necessary is, that the initially
allocated memory block may not increase in size because the neighborhood in the RAM
is already occupied by other data. Now let us see want we can do with arrays and
sequences

----
var
  a: array[8, int]
  v = 1
for el in mitems(a):
  el = v
  inc(v)
for el in mitems(a)
  el = el * el
for square in a:
  echo square
----

In the second line we declare a variable named a of array type -- we want to use an
array with exactly 8 elements, and each element should have the data type int. The
first for loop fills our array, that is for each of the 8 storage places in the array
we fill in some well defined data. We use the [.term]#mitems()# iterator here, because we want
to modify the content of our array -- we fill in numbers 1 .. 8. In the next for loop
we square each storage location, and finally we print the content. In the last for
loop we do not modify the content, so a plain items() instead of mitems() would work,
but we already learned that we have not to write the plain items at all in this case.

Sequences work very similar like arrays, but they can grow:

----
var
  s: seq[int]
  v = 0
while v < 8:
  inc(v)
  add(s, v)
for el in mitems(s)
  el = el * el
for square in s:
  echo square
----

We start with an empty seq here, and use the [.term]#add()# procedure to append elements.
After that we can iterate over the seq as we did for the array.

In the same way as we accessed single characters of a string with the subscript
operator, we can use that operator to access single elements like in a[myPos]. The
first element position is generally 0 for arrays and sequences. Arrays can even be
defined in a way that the index position starts with an arbitrary value, but that is
not used that often. Whenever you use the subscript operator you have to ensure that
you access only valid position, that is positions that really exists. a[8] or s[8]
would be invalid in our above example -- the array has only places numbered 0 .. 7,
and for the seq we have added 8 values which now occupy positions 0 .. 7 also,
position 8 in the seq is still undefined. We would get a runtime error if we would
try to access position 8, as well when we would try to access negative positions.

Note that in some languages like Julia arrays start at position 1. Nim array can
have arbitrary integral start position, including negative start positions, but start
position as well as highest subscript position are determined in the program source
code and can not change at runtime. We say that arrays have fixed compile-time
bounds. Seqs start always at position 0, we can specify an initial size, and we can
always add more elements at runtime.

Arrays and sequences allow fast access to its elements: All the elements are stored
in a continues memory block in RAM, and the start location of that memory block is
well known. As all the elements have the same byte size, it is an easy operation to
find the memory location of each element. The compiler uses the start location of the
array or seq, and add the product of subscript index and element byte size. The
result is the memory location of the desired element, which was selected by the index
used in the subscript operator. When the array should not start at position 0, then
the compiler would have to adjust the index, by subtraction of the well known start
index. This operation takes not much time, but still arrays starting at position 0
are a bit faster. We said that the compiler has to do a multiplication of index and
element size -- that is an integer multiplication, which is very fast. When the
element size is a power of two, then the compiler can even optimize the
multiplication by using simple shift operation, which may be even faster, depending
on your CPU.

It should be not surprising that the internal structure of seqs are a bit more
involved than arrays. Arrays are indeed nothing more than a block of memory,
generally allocated on the stack for local data or allocated in the BSS segment for
global data. Don't worry when you have not yet an idea what the stack, the heap and a
BSS segment is, we will learn that soon. The Nim seq data type has a variable size,
so it is clear that it needs not only a storage location for its elements, but also a
counter to store how many elements it currently contains, and another counter how
many it could contain at most. The element counter must be updated when we add or
delete elements, and when the counters tells that there is currently no more space
available for more elements, then a new block of memory must be allocated, and the
existing elements must be copied from the old location into the newly allocated
memory region, before the old memory region can be released. Due to this additional
effort appending elements to a seq by using the add() procedure is not extremely
fast. You may wonder why we have not to save a size information for arrays. Well
arrays have fixed size, so it is obvious that we never have to adjust something like
a size counter, simple why it would never change. But would we have to save the
desired initial size of the array? Well, in some way yes. But it is a constant value.
During the compile process the compiler can catch some errors already for us -- when
we have an array as above with size 8, then the compiler would be able already at
compile time to recognize some invalid access to array elements -- a[9] would be a
compile time error for sure. But at runtime, when we execute our program, access to
not existing index position may occur, for example by constructs like var i = 9; a[i]
= 1 when the array is declared as var a: array[8, int]. For catching that type of
error the compiler has to store the fixed array size somewhere and to check against
that value when an array access by using the subscript operator with a non constant
argument occurs, as the a[i] above. One related remark: Accessing array elements is
as fast as ordinary variable access when we use a constant value as index, that is a
constant literal or a named constant. The reason for this is, that when index is a
constant, then the compiler just knows the exact position of that array element in
memory, just as it knows the address of plain variables, so there is no need for
address calculations at runtime.

We said that appending elements to seqs is not extremely fast -- indeed it is a few
times slower than access to an array element by its index using the subscript operator. So when we know that our
seq will have to contain at least an initial amount of elements, then it can be useful
for maximum performance, that we allocate the seq from the beginning for this size
and than fill in the content by use of the subscript operator instead that we append
all the elements one by one.

----
var s: seq[int] = newSeq[8, int]()
var i: int
while i < 8:
  s[i] = i * i
  inc(i)
----

Here we used the newSeq() procedure to initialize the seq for us, the content of the
square brackets tells the newSeq() procedure that we want a sequence with 8 elements
of type int. The call of the newSeq() procedure may look a bit strange indeed. That
procedure is a so called generic procedure, it needs additional information, which is
how many entries the returned sequence should have, and what data type the elements
should have. Don't confuse the square bracket in the newSeq[8, int]() call with the
subscript operator a[i] which we have used for array access, bot are completely
unrelated. And note that the empty parameter list after the square bracket in the
newSeq() call is necessary to tell the compiler that we want to call a procedure.
Also note that the initialization of the seq above does not restrict its use in any
way, we can still use it as an uninitialized seq, that is we can use the add()
operator to add more elements, we can insert or delete elements and all that.

== Value Objects and References

We have already used different types of variables -- integers, floats, or the custom
Computer object, and some more. We said that variables are named memory regions,
where the content of our variables is stored. We call this type of variables also
value objects.

Value objects always implies copies when we do an assignment

----
var i, j: int
i = 7
j = i
i = 3
echo i, j
----

Here we have 3 assignments, first we assign the integer literal 7 to variable i, then
we assign the content of variable i to variable j, and finally we overwrite the old
content of variable i with the new literal value 3. The output of the echo statement
should be 3 and 7, because in line 3 we copy the content of variable i, which is
currently the value 7, into variable j. The new assignment in line 4 in no way
touched the content of variable j.

Maybe that is not too surprising, but when we would have references instead of plain
variables, then the situation would be different, as we will see soon.

Whenever possible we should use this simple form of variables, as they are fast and
easy to use.

But there exist situations where we need some sort of indirection, and then
references and pointers come into play. For example when the data entities depend in
some form on another, the elements may build linked lists, threes or other
structures. The entities may have some neighborhood relation, also called some one to
many relation.

Indeed value objects and references occur in reals life also:

Imagine you have baked a cake for your family, and you know that your friendly
neighbor loves cakes too. As you have still a lot of all necessary ingredients and
because the oven is still hot, you make one more identical cake to give it later to
your neighbor. We can think of the cake as a value type, and your second cake can be
considered as a copy. When you give the copy to your neighbor, then you have still
your own, and when you or the neighbor eats the cake, then the other one still
exist.

Now imagine that you know a good car repair shop. You can give the telephone number
or location of that car repair shop to your neighbor, so he can use that shop too. So
you gave him a reference to the shop, but you gave him not a copy. You can although
give some of your other friends each a reference to that shop, which is nearly no
effort for you. While backing a cake for all of them would be some effort.

You can regard names of persons as some sort of reference too. Imagine you have a
list with the names of all the people you intend to invite to your birthday party,
and another list with names of people who owe you money. Some names may be on both
list, this it is refer to the same person.

In computers the dynamic storage, called RAM, consists of consecutive, numbered
storage locations, called words. Each individual word has its address, which is a
number generally starting at zero and extending to a value which is defined by the
amount of memory available in your computer. These addresses can be used to access
the storage locations, that is to store a value at that address, or to read the
content again. Reading generally does not modify the content, you can read it many
times and will always get the same value. When your write another value to that
storage location, then reads will give you that new value.

Basically for all the data that you use in your program you need in some form its
address in the RAM, without the address you can not access it. But what is with all
the plain, value object variables we have used before, we have never used addresses?
That is true -- we used only names to access our variables, and the compiler mapped
our chosen name to the actual address of the variables in memory whenever we accessed
the variable. For most simple cases this is best way to access variables. Now let us
assume we have such value object type of variable declared in our program, can we
access it without using its name? When we have declared it, it should reside
somewhere in the RAM when the program is executed. Well, when we do really not want
to access it by variable name, then there is still one chance: We can search in the
whole RAM for the desired content. In practice we would never do that, as it is
stupid and would take very long, but we could do. But how can we detect our
variable? How can we be sure that is is indeed ours? Generally we can not. Even when
we are sure that the variable must reside somewhere in the RAM, generally the
variable is marked in no way of course. Even when we would know the value which is
stored in that variable, we would only know what bit pattern it should have, so for
most words of the RAM with a different bit pattern we could say for sure that it can
not be our variable, but whenever we find the expected bit pattern than it can be
just an coincidence, there can be many more words in RAM with that content. In some
way it is as you would search a person and you know that that person lives in a long
road with numbered houses. If you only know that the person wears brown shoes but you
know not the number of the house nor the name of the person and no other unique
property of that person, then you have not much luck.

== References and Pointers

=== Introduction to Pointers

In Nim references are some form of smart or managed pointer, we will learn more about
references later. The plain pointer data type is nothing more than a memory address,
it is similar to a (unsigned) integer number. We say that a pointer points
to an entity when the pointer contains the memory address of that entity.

Beside the pointer data type, which is only some RAM address, we have also the ptr
entity. Ptr is not a datatype for its own, it is always used in conjunction with
another data type:

----
var
 p: pointer 
 ip: ptr int
----

Here the variable p is of type pointer, we could use it to point to some arbitrary
memory address. The variable ip is of type [.term]#ptr int#, which indicates that it should
only point to memory addresses where a variable with data type int resides. So a ptr
is a pointer that is bound to a specific data type. Generally we speak only about
pointers, if we are referring to an untyped pointer or a typed ptr is generally clear
from the context.

When we only declare pointers but do not assign a value then the pointers have the
value [.term]#nil#, what indicates that they are regarded to point to nothing. Exactly
speaking a pointer can never point to nothing in the same way as an integer variable
can not contain no number. As an integer variable always contains a bit pattern, a
pointer also always contains a bit pattern. But we are free to define a special
pattern as nil, and whenever a pointer has this special value, then we know that it
does not really point to something useful. In C instead of nil NULL was chosen for
the same purpose. In practice nil and NULL are generally mapped to 0, that is a word
with all bits cleared. But that is more or less an arbitrary decision.

So how can we give our pointers above a useful value?

One possibility would be to use Nim's addr() function, which gives us the memory
address of each ordinary variable.

[source, nim]
----
var
 number: int = 7
 p: pointer 
 ip: ptr int
echo cast[int](p)
echo cast[int](ip)
p = addr(number)
ip = addr(number)
echo cast[int](p)
echo cast[int](ip)
----

First we declare an ordinary integer variable called number which will reside
somewhere in memory when we execute the program, and then we use the addr() function
to assign the address of that variable to p and ip. The addr() function is a low level
function provided by the compiler, it can be used to determine the memory address of
variables and some other entities known to the compiler.footnote:[Sometimes the compiler
may refuse to accept the addr() function, for example for variables defined with the let keyword.
For that case we may have to use the function unsafeAddr().] 
We used the echo() procedure to
show us the numeric decimal value of the addresses in the terminal. As it generally
makes not too much sense to print addresses, echo() would refuse to print it, so we
have used the construct cast[int](someValue) to tell that echo() should regard our
pointers as plain integer and print it. That operation is called casting, we
generally should avoid it, as it destroys type safety, but for learning purposes it
is OK to use it. We will learn more about casts and related type conversion later.

The first two echo statements should print the decimal value 0, as the pointers have
the initial default value nil.

The echos in the last two lines should print a value different from 0, as we have
assigned the valid address of a ordinary variable that resides somewhere in the RAM
when the program is executed. Both outputs should be identical, as we have assigned
for both pointers addr(number) each.

Maybe a funny fact is, that when you run the program multiple times the output of the
last two echo() statements print different values. But that is not really surprising
-- whenever you launch the program, then for our variable number a storage location
in RAM is reserved. And that can differ for each new program execution. For your
next holiday in the same hotel, you may get a different room also.

So when we have the pointer ip pointing to a valid address, can we recover the
content of that memory region?
Sure, we use the de-reference operator [] for that purpose. Whenever we
have a typed pointer x we can use x[] to get the content of the memory location where
the pointer is pointing to. Note that the operator [] is not really related to the
subscript operator [pos] which we used earlier for array, seq and string access. Nim
uses ASCII characters for its operators, and that set is not very large. And maybe
it would even be confusing when we would have a different symbol for each operator.
We can consider [] as some form of content access operator -- mystring[pos] gives us
the character at that position, and ip[] gives us the content of the memory location
where ip points to.

[source, nim]
----
var
 number: int = 7
 ip: ptr int
echo cast[int](ip)
ip = addr(number)
echo cast[int](ip)
echo ip[]
----

What do you expect as output for the last echo statement? Note that for the last
echo statement we do not need a cast, as ip[] has a well defined type: ip has type
ptr int, so ip[] is of well defined type int and echo() can print the content.

Now let us investigate how we can use pointers to modify the content of variables:

[source, nim]
----
var
 number: int = 7
 ip: ptr int
ip = addr(number)
echo ip[]
ip[] = 3
echo ip[]
echo number
----

What do you expect for the output of the last echo() statement? Well remember, ip
points to the location where variable number is stored in RAM. So echo ip[] gave us
the content of number. Now ip[] = 3 is an assignment, the right site of the
assignment operator is the literal number 3, which is a value type. Earlier we said
that for value types an assignment is a copy operation, the right site of the
assignment operator is copied into the variable on the left site. Now ip[] stands
exactly for the same content as the name number, and so assigning to ip[] is the same
as assigning to number.

=== Allocating Objects

In the previous section we learned the basics about pointers. We used the
addr() operator to initialize the pointer by assigning the address of an already existing
object. This is in practice not that often done, and it can be a bit dangerous, as
it is not always guaranteed that the variable on which we applied addr() will
exists as long as our pointer exists. So the pointer may point later to a memory location
that is already freed or used by a totally different object already. So the use
of addr() is more reserved for advanced programmers who know well what they do, and 
most of the time addr() is not necessary at all or is only necessary for really
low level code, maybe when interfacing with external libraries written in C.
Instead of using addr() to assigning to pointers a valid address, often procedures
like alloc() or create() are used to reserve a block of memory:

----
var ip: ptr int
ip = create(int)
ip[] = 13
echo ip[] * 3
var ip2: ptr int
ip2 = ip
echo ip2[] * 3
dealloc(ip)
----

Here the procedure create() is used to reserve a block of memory, the int parameter
ensures that the block has the size of an integer value. After ip has a valid value,
we can store a value in that memory location and read it again. Note that multiple pointers
can point to the same memory location: We declared one more int ptr called ip2. But for
that pointer we do not allocate a new block, but we assign the old block that we
allocated for ip to ip2. Now both pointers points to the same object, the int value 13.

When we use alloc() or create() to allocate memory blocks, then we have
to deallocate them when we need them not any more. Otherwise that memory
blocks couldn't be reused. If we would continuously allocate memory blocks  and never
deallocate, that is free then, then at some point in time all memory would be
occupied -- not only for our own program, but for all programs running
currently on the same computer. We had to terminate our program -- when
a program is terminated then all resources get freed automatically by the OS.

The use of procedure pairs like alloc() and dealloc() is common practice in low level
programming languages like C, but it is inconvenient and dangerous: We can
forget to call dealloc() and waste resources, or we may even deallocate
memory blocks but still use it by our pointers. The later would at some point
of time crash our program, as we would use memory blocks which are already
released and may be used for other variables -- from our own program
or from other programs. Note that in the source code above there is only one
single dealloc() call. The reason for that is, that we only allocated
one single memory block in  one single create call, ip2 is only one more 
pointer that points to that block. If we would have used an addition
dealloc(ip2) call, then that would be a so called double free error.

As you see, using pointers is inconvenient and dangerous. But still
there are situations where plain value type variables do not suffice.
The solution of many higher level programming languages to this problem
is a Garbage-Collector (GC). The GC does the dangerous and inconvenient
task of deallocating unused memory blocks for us automatically.

To distinct the GC managed "pointers" cleanly from the manually
managed onces, we call them in Nim [.term]#references#, in some
other languages they are called traced pointers. References
are always typed like ptr, there is no equivalent to
the untyped pointer type for references.

For References we have still to do the allocation our self, then we
can use the references, and when we are not using then any more, then
the GC frees the corresponding memory block. A typical scenario is
that we use references in a procedure or in a otherwise
limited block of code: We declare the reference in that code block,
allocated and use it, and when the code block is left the GC frees
the allocated memory for us. You may think that the fact that we still have to
allocate the memory for our references our self is still a problem,
as we may forget that step. Well it is not that dangerous, when we forget
the allocation step, we would use a reference with value nil, which would immediate
result in a runtime error. So we would see the problem immediately. Other
pointer errors, like missing de-allocation or use after free are not that obvious
and more dangerous.

With references we can rewrite our previous example code in this way:

----
var ip: ref int
new(ip)
ip[] = 13
echo ip[] * 3
var ip2: ref int
ip2 = ip
echo ip2[] * 3
----

We have replaced ptr by ref, and instead of alloc() or create()
we are using the new() proc which gets the uninitialized ref
as a parameter and allocates a managed memory block for it,
that is after the new() call ip has a well defines value referring to a
managed memory block that can store an integer value.
Again, we can use one more ref and assign that ref the value
of the other, so now both references the same memory block.
The advantage here is that we don't have to care about freeing
that block, the GC will do that when appropriate.

To verify that in the example code above both references really
reference the same object in memory, we could add two more lines
of code:

----
ip2[] = 7
echo ip[]
echo ip2[]
----

Here we are using the reference ip2 to assign to
the memory block the literal value 7. After that assignment
both echo statements would display that new content.

Using references and pointers to store basic data types
like integers is not done that often, in most cases 
we work with larger objects, and we create some relation
between the objects. We will try that in the next section.

=== References to Objects

You should still wonder for what references are really useful --
they seems to be only a more complicated version of plain
value type variables.

Now let us assume we want to create a list of things or persons,
maybe a list of our previously used Computer data type, or
maybe a list of persons we will invite to our next party.
We will create the party list for now, as the Computer
data type we used before has already many fields, and 
filling all the fields would be some effort, so let us use
a new Friend data type which should store only the friends
name for the beginning -- we may add more fields later
when necessary. So we may have

----
type
  Friend = object
    name: string
----

With that declaration we could declare a few friends variables
like

----
  var harry, clint, eastwood: Friend
----

But that is not what we want, we would need a list
with all of our friends that we would like to invite
to our party, we would want to add friends to the list, and
maybe we would want to delete friends also. You may think we
could use Nim's sequence data type for that, and you are right.
But let us assume we could not use that predefined Nim data
type for some reason. Then we could create a list of linked
references to Person.

----
type
  Friend = ref object
    name: string
    next: Friend
----

Now our Friend data type is a reference to an object,
and the object itself has an additional next field
which is again of type friend.

That is some sort of recursion. If that should appear as too
strange, then imagine you have some numbered paper cards, each with two
fields: One field name, one field next: In the name field you can
fill in a name of a friend, in the next field you fill
in the number of the next card. The last card in the chain
gets no entry in the next field.

Now we create a small Nim program which reads in names of our
friends from the terminal, creates a list of all friends, and
finally prints the list.

[source, nim]
----
type
  Friend = ref object
    name: string
    next: Friend

var
  f: Friend
  n: string

while true:
  write(stdin, "Name of friend: ")
  n = readline(stdin)
  if n == "" or n == "quit":
    break
  var nxt: Friend
  new(nxt)
  nxt.name = n
  nxt.next = f
  f = nxt

while f != nil:
  echo f.name
  f = f.next
----

This example code seems to be not that easy. But it is not really difficult, and
when you have understood it, you can call yourself a Nim programmer already.
Maybe you should think about the code above for a few minutes before reading the
explanations below.

First let us summarize what our program should do: It should read in some
names of our friends which we would like to invite to our next party.
Of course when entering the names, we would need a way to tell
that we are done. In  our program we can do that in two ways, we
can enter an empty name by just pressing the return key, or we
can enter the text "quit" to stop the loop. Unfortunately that means
that we can never invite a friend with that name to our parties.
When we have terminated the input loop, then the next loop
prints all the entries to the terminal.

Let us start with the type and variable declarations:
We use a user defined type named Friend which is a reference
to an object, that object type has a field name of type string,
and a field next which is again a reference to the same data type.

We are using two variables, on called n of type string to read
in a name or the quit command from terminal, and a variable called f
of type Friend. The variable f seems to match only to one single
friend, but as the type of f has a next field it can be a whole list
of friends, with f being the start or head of that list.

In the code above we are using a special while loop -- special
because the construct [.term]#while true:# and because the loop contains
a break statement. Earlier we said that we should avoid the
break statement in loops, because it interrupts the control flow and
can make it more difficult to understand and proof the flow.
But in this case that form makes some sense: For the first loop
we have to first read in a name from terminal and then we can decide
what to do, so we can not really evaluate a condition after
the while statement at the top. So we use the simple constant condition true,
which would never terminate the loop. We need a break inside the loop body to
terminate the loop.

//The second loop is also some sort of special -- we stop when
//the next field of our object variable is nil. But we can have the special
//case that we habe a list with only one freind, so next is nil for the
//first entry in the list, but still we had to pront the name of that
//single entry. Our form of the output loop covers this case well. We could
//rewrite boths loops without using a braek, but that would require some addidional code.

Let us investigate the second loop first as it is really easy:
In the while condition we check if current value of f is nil, that
is if there are no more entries in our list. For that
case we terminate the loop, as we are done. If f has not the
value nil, than f points to a valid content, that is there
is at least a valid name, which we access by the field access
operator and print it with echo f.name. Note that in Nim the
field access operator . works in the same way for value objects types as
well as for ref objects types. For ref objects types we could also write
f[].name instead of plain f.name, that is we first apply [] to
f to get the content, and then use . to access the name field.
In some other languages like C we would have to use
a special operator -> to access fields of pointer or reference types.

The most interesting statement in the output loop is f = f.next.
We assign the content of f.next to f and proceed with that new
content. The content could be a valid reference to one more friend object,
or it could be nil, indicating that our loop should terminate.

The input loop is also not that complicated: First we ask the user
to enter a name. We use write(stdin) for this, as echo()
always generates a newline, but we want to read in the name on the same line.
If the name is empty or has the special value "quit" then we terminate the input
loop. In the loop we are using a temporary variable nxt of type Friend, we
allocate a memory block for it with new(). Then we assign the read in name n to
the name field. The last two statements of the loop body are a bit demanding:
First we assign to nxt.next the value of f. Now nxt is basically the start of our list,
and it next field refers to the first element of the current list. Fine, but we said that
the nxt variable is only a temporary variable, we do not intent to use it longer as necessary.
But currently nxt is so useful, it is the head of our list. On the other hand, the former
list start f is now useless, current f is identical with nxt.next. So the trick is, we just
assign to f the value of nxt. Now f is the complete list, and we do not need nxt any more.
nxt can be used in the next loop iteration again, but we have to allocate a new memory 
block for the nxt reference, as the previous memory block is still in use, it contains the 
name which we just entered and also a reference to the next object in the list.

Note that we add the new elements at the top of the list in this way. We have done it that way
because it is very easy in this way. For adding at the end of the list, we would have to
use one more reference variable which allows us always access to the current end of the list, or
we would have travel the list from head to tail whenever we would like to
add elements at the tail.

For one more exercise let us consider deleting entries in our list. Basically
that operation is very easy, we would just skip one entry. Lets adds this code to the
program above:

[source, nim]
----
while f != nil:
  write(stdin, "Name to delete: ")
  n = readline(stdin)
  if n == "" or n == "quit":
    break
  if f.name == n:
    f = f.next
  else;
    while f.next != nil:
      if f.next.name == n:
        f.next = f.next.next
        break
      f = f.next
----

Here we are using again an outer while loop to read in the names
which we want to delete. That loop uses the condition while f != nil:
because when the list is empty we should stop of course.

In the loop body we have an if statement, and
in the else branch of the if statement we have one more loop.
The reason why we need the if statement is, that the case that our
name to delete is the first in the list is some sort of special. Let us
//list contains only a single entry is some sort of special. Let us
investigate the inner loop first. That loop assumes that 
there are at least 2 elements in the list, f and f.next.
We compare the name of the next entry with n. If they match then we would have to
skip the next entry. We can do that by the statement  f.next = f.next.next. That is
we replace the reference from the current element f to the next list entry, that is 
f.next, by the next entry of the next element, which is (n.next).next. We do not have
to write the parenthesis. The n.next.next entry can be nil, in that case it is the end
of the list. If we found a matching name then we terminate the inner loop 
with a break statement, and we are done. Otherwise we assign to f the value of f.next and continue the loop
execution. Now to the special case that the name to delete is the first in the list.
//our initial list contains only a single entry.
//For that case the initial
//test of our inner loop  while f.next != nil: would be false, we would do nothing.
//If this case we have to set f to the next element in the list
We need the first if branch for that -- if already the first element matches
the name to delete than we just skip the first element by setting the head of the list to
the next entry, which may or may not be nil.

This is one way to solve the task, for operations on lists there exist in most
cases various solutions, some optimized to easy or short code, some for performance.
You may copy the code segment below to the end of the former code, and maybe 
add one more copy of our printing loop at the end again. Then you should have a program
that reads in a list, prints the contents, then ask for names to delete, and finally
prints the resulting list. Maybe you can improve the code, or maybe you can detect
special corner cases where it may fail. What is for example when some of your
friends have the same name? May the program fail in that case? Or you may 
add more fields to your Friend data type. Maybe a textual field with
content male or female, and you can report the ratio of male to female.
And maybe remove males from the list when we have more males then females?

== Arithmetic -- Integers and Floats

== Procedures and Functions

=== Introduction

Procedures and functions, called proc and func in Nim, are
the most common way to structure larger programs in smaller parts
with a dedicated task. The terms procedure and function where
used in Pascal and the other languages of Wirth already, while
C uses the term function only, and Fortran generally uses the 
term subroutine instead. And Python and Ruby finally are using
the really strange names def and fun for it.

We call or invoke a proc by just writing its name followed
by a parameter list enclosed in parenthesis. The
parameter list can be empty. When we call a proc, then
the program execution continues with that procedure, 
and when the execution of the procedure terminates, then the
next statement after that proc call is executed. Sometimes
we say that we jump into a procedure and jump back when that
procedure terminates.

In Nim functions are a special form of procedures that return
a result and does not modify the current state of the program.
Modifying a global variable or an output operation would be
examples for modifying the state. We have already used some
predefined procs like echo() for output operations, add() for
appending single characters to strings, and readLine() for
reading in textual user input. And we talked
about math functions like sin(), cos(), pow() -- these
are functions as they accept one or two arguments and return a result
but do not change a state -- calling them again with the same
arguments would always give the same result. ReadLine()
is only a proc, not a function, as the result may be different
for each call, and as we pass a file variable as argument, which
may change its state for each call, maybe because the file end is reached.
A function is only a special subtype of a procedure, the
func keyword indicates to the reader of the code and to the compiler
some special properties, that is that a result is returned
and that global state is not changed. Whenever the func keyword
is used a proc would do as well, and in this text we generally
speak about procedures, even when a function would do.

Let us start with a very simple function called sqr() for square.

----
func sqr(i: int): int =
  i * i
----

A procedure declaration consists of the keyword proc, a user
selected name, a optional parameter list enclosed in
parenthesis  and an optional colon followed by a data type.

Note that this is only a declaration so far -- the
compiler could recognize the construct, its parameters
and its result type. Sometimes we call this construct
a procedure-header.

Generally we do not only declare a function, but we
define it, that is we add a equal sign to the
procedure header and add an indented procedure body
that contains the code that is performed for each
invocation.

Pure proc declarations can be necessary in rare situations, maybe
when two procedures call each other. In this case the procedure
defined first would call the other procedure, which is not
already defined, so the compiler may complain about a unknown
procedure. We could solve that problem by first declaring the second
procedure, so that the compiler would know about it existence.
We would then define that second procedure later, that is
closer to the end of the program file.

The sqr() proc above accepts an integer argument and
returns its square of same data type. We would
call that proc like

----
var j: int
j = 7
echo sqr(j)
----

Earlier in this book we said that the compiler processes
our source code from top to bottom, and that the final
program is executed from top to bottom too. The first
statement is indeed true, for that reason it can be 
necessary to declare a function at the top, and define
it below, as we can not call a proc before it is declared or defined.

For the program execution  we have to know that
procs are only executed when we call them. That is, when 
we write a proc at the top of our source code, then that
proc is processed by the compiler, but it is not executed
during program runtime before we call it. 

Our sqr() function above accepts only one parameter and
that
parameter is a value type, which indicates that we can not
modify it in the procedure body. That fact is useful to
know for the caller of a proc, as one can be sure that 
the passed parameter is not modified and is available
unchanged after the proc call. But of course there
are situations where we may want that a passed parameter  
is modified. Let us assume we want to "frame" a passed
string, for example we want to pass in the string "Hello"
and want to change it to "* Hello *". Further let 
us assume that we may sometimes want to use other
characters instead of the asterisk, maybe a + sign.

[source, nim]
----
proc frame(s: var string; c: char = '*') =
  let cs = newString(2)
  cs[0] = c
  cs[1] = ' '
  insert(s, cs)
  add(s, ' ')
  add(s, c)

# we can call that proc like
var message = "Hello World"
echo frame(message)
echo frame(message, '#')
----

The frame proc above accepts two parameters and returns no
result. The first parameter has the type string, it
is not a value parameter but a var parameter, which
is indicated by the var keyword between the colon and the
type of the parameter. Note that we use here again the keyword var
that we used earlier to declare variables. The main  reason that we
use again the same keyword is that we do not want to use a new one --
var proc parameters are different from var declarations.
Var parameters can be modified in the
procedure body, and that modification is visible after the proc call.
The second proc parameter is a plain value type, it is a character
which has the default value '*'. Default values are useful for
parameters that have in most cases the same value, but can be
different sometimes. The advantage is, that when calling that proc
we can just leave that parameter out. For default values we have to
be a bit careful, only value parameter can have default values, and
when we call a proc with many parameters with default values it
may be not always clear which parameter we pass and for which parameter we want a default value.

To generate the frame around the passed in string we have to insert two characters
at the front of the string, and to append two characters. Inserting in strings
is not a very cheap operation, as it involves moving all following characters.
So we try not to insert two single characters, but we first create
a short string consisting of the passed c character and a whitespace character, and
then insert that two character string at the front of the passed string.
We use the standard procedure newString() with parameter 2 to create a new
string of length 2 with undefined content, and then fill in the content
by using the subscript operator. We could have used the add()
proc to add that two characters to an empty string, but that is a bit
slower. Then we use the standard procedure insert() to insert our two
character string at the front of our passed string. Finally we
add a whitespace and the c character to the passed string.
The passed string is now modified, it is 4 characters longer. That
modification is noticeable for the caller of that proc, that
is echo() will print the modified version.

When we call a proc or function with multiple arguments, then we have
to pass the arguments in the same order as they are specified
in the proc declaration.

Our frame() proc above modified the passed string. We could have
instead decided that the proc should not modify the string, but should
return a new string consisting of the frame and the passed string in the center.
Generally when creating procs we have to decide what is more useful -- modifying a 
passed value or returning a modified copy. And sometimes we have to
regard efficiency too. Returning newly created large data types
like strings may be expensive. A string is not a trivial structure, as 
it contains the dynamic buffer for the string content, which has to
be allocated. On the other hand, for the passed var string we inserted
characters, which involves moving characters and is also not 
a really cheap operation, and maybe when we insert a lot, the
string buffer must be even enlarged, which is again expensive.
So for this use case it is not really clear what approach is better -- 
we used the var parameter mainly to introduce var parameters.

The execution of a procedure terminates when the
last statement of the procedure body has be processed.
We can also terminate a procedure earlier when we
specify a [.term]#return# statement somewhere.

Functions and procedures which return a result
can also terminate with the last expression of
the procedure body, or earlier with a return expression
like [.term]#return i * i#. Functions and procedures with a result
declare automatically a result variable for us, which we may
use or just ignore. So for our previous sqr() function we have
various ways to write it:

----
func sqr1(i: int): int =
  i * i

func sqr2(i: int): int =
  result = i * i

func sqr3(i: int): int =
  return i * i
----

For short and simple procedures
the first form is often used. For longer procedures
where the result is constructed in multiple
steps, like some string operations, using the
result variable makes sense. And finally, when
there exist multiple points where we may jump back
using return statements may make sense. One use
case is an early error check, maybe we want to
return -1 as some form of error indication when 
we write a procedure that should calculate the
square root of an integer value. (Well in Nim we have 
other and sometimes better ways to catch errors, we
will learn about that later.)

Note that we used the proc names sqr1, sqr2 and sqr3 above.
Using the same name with the same argument types multiple
times would result in a redefinition error, as the
compiler could not know what proc body should be executed
when that proc name is called.

But Nim supports so called proc overloading, that is
we can use the same name when the parameter list is different,
as the compiler can select from the parameters in the proc call
which proc has to be called:

----
func sqr(i: real): real =
  i * i
----

We have only changed the parameter and result data type.
Now there is no conflict with the proc with same name which
we defined for integers. Note that Nim use only
the parameter list for overload resolution, but not the
result type of a proc or function. The reason for that
is that Nim supports type inference, and that would not work
when we would have two procs with same name each accepting a int parameter 
but one returning an int and one returning a float number.

Nim does also support named arguments in proc calls, that is we could invoke
the proc above with sqr(i = 2.0). Named arguments
can be useful when procs or functions have many arguments,
maybe some with default values, and we do not remember
the order of parameters or when we want to specify only a few.

=== Special argument types: OpenArray and Varargs

The openArray and varargs data types can be used only in 
parameter lists.
OpenArray is a type which allows to pass arrays and seqs
to the procedure or function. Allowing that makes
sense as arrays as well as seqs store their content
in a block of memory, which can be processed uniformly.
Although arrays generally do not have to start with index
number 0, when passed as openarray the first element
is mapped to index 0, and the index of the last element is
available by using the high() function on the passed array
parameter. Whenever we write a proc that accepts an array
or a seq, we should consider using the openArray parameter type
to allow passing in both data types. Strings can be passed although
to procs accepting openArrays with char base type.

The varargs data type allows passing a variable number of
arguments to a proc or function, and we can
iterate over the arguments in the proc body:

----
proc print(s: varargs[string]) =
  for el in s:
    stdout.write(el)
    stdout.write(", ")
  strout.write('\n')

print("Hello", "World")
----

There exists a variant of the varargs data type that
performs a type conversion automatically by applying a
proc on the arguments. For example varargs[string, `$`]
would apply the stringify operation on the passed arguments
automatically. That is what echo does.

Varargs arguments may be only allowed for the last
argument in a parameter list.

=== Scoping , Visibility and Locality

Scoping, visibility and locality is an important concept in computer programming
to keep the source code clear. Imagine that a variable which we declare at some point
in our program would be visible everywhere. That would even for medium size
programs generate a lot of confusion -- whenever we would need a variable we would
have to carefully check which names are already in use. And for performance it would be
bad also, as all variables declared somewhere would reside permanently in  memory.

So most programming languages including Nim support the concept of locality --
names declared inside of a procedure body or inside another form of block are
only visible there and can only be used there. We say that they are only visible
in that scope. For Nim we can say that whenever Nim's syntax requires a new level of
indentation, that is a new statement block, then all symbols declared in that block
are only visible in that block and in sub-blocks of this block, but not outside of
that block. Nim has another important concept of visibility, which is called
modules and allows separation our code in logically separated text files with
well defined visibility rules, we will discuss modules later.

Visibility is really a simple concept, let us regard this useless example:

----
var e: float = 2.7

proc p1 =
  var x: float = 3.1415
  if x > 1.0:
    var y = 2.0 * x
    echo y # OK
  echo x # OK
  echo y # compile error, y is not visible
  echo e # OK, e is declared globally, so it is visible everywhere

echo e # OK
echo x # ?
echo y # ?
----

In line one we declare a so called global variable, that one is visible
after declaration, that is below the line where it is declared, in the whole
program. The variables declared in the proc p1 are called local variables,
they are not visible outside of that proc p1. The variable x is declared
at the start of the proc body and is visible in the whole proc everywhere, while
variable y is declared in the if block and is visible only there. So
it should be clear if the last two echo statements for x and y compile fine?

Related to visibility of variables is their lifetime, that is
the duration how long they exist and how long they can store a value.
Global variables exist for the whole program runtime -- when you have
assigned a value to it that value can be used everywhere as long as the program
runs, and as long you do not assign a different value of course.
Global variables are generally stored in a special memory region that is called the BSS
region.

Variables of value type defined locally inside a procedure or function do exists
only for the execution time of that proc, that is they are created when the proc
is invoked and vanish when the proc terminates, that is when execution
continues with the statement following on the proc call.

Local variables declared in a proc reside in a special memory region of the RAM which is called
the stack. The stack is nothing more than an arbitrary part of the hole ram that is used in some
clever fashion: The memory words in it are used in consecutive order. A so called stack
pointer is used to indicate the address of the first free area in that stack. So when a 
proc is called, which may have n bytes of local variables, then the compiler can use
the area where the stack pointer points to for that variables, and when the proc 
is called then the stack pointer is increased by that size. So the stack pointer
points again to the next free area of the stack, and another proc can be called
in the same way from within the current proc. Whenever a proc terminates, the stack
pointer is set back to the value which it had when the proc starts execution.
This method of memory management is simple and fast, but it does only
work when the total amount of memory that the local variables in a proc 
needs is known at compile time, so that the compiler can adjust the
stack pointer accordingly. It does not work for dynamically sized data types
like strings or sequences.

Note that pointers and references are value types itself, we can regard 
pointers and references as a plain integer variable interpreted in a special way --
as a memory location. But the memory blocks to which the pointers and references 
may point and that is allocated by alloc() or new() is different: That memory blocks
are not allocated on the stack, but in the ordinary RAM which we call heap to
separate it from the stack.

So why can the stack not be used for memory blocks which alloc() or new provides for us:
An important fact for the use of the stack to store variables is that
the total size which is needed by a proc for all the static variables must be a
compile time constant. The stack pointer is adjusted by that amount when the
proc starts and all the local variables are accessed with a fixed offset to
that stack pointer then. When we use alloc() or new() in a proc, then we may
call that multiple times like we did in our previous list example, and for
alloc() an additional fact is that the byte size that alloc() should reserve
can be a runtime value. So the total amount of ram that alloc() or new()
would allocate is a runtime value, and we can not use the stack for it. Instead
alloc() and new() allocates block of memory in a more dynamic fashion, which is
basically that they ask the OS for a free block of right size somewhere in the
available RAM. That block is later given back to the OS for reuse by functions like
dealloc() or automatically by the GC.

Let us at the end of this section investigate some special
cases:

While in languages like C we have always a well defined main()
function and all program code is contained in this function
or in other functions which are called from this main function, in Nim we have
also global code as in scripting languages Ruby or Python:

----
var i: int
while i < 100:
  var j: int
  j = i * i
  echo j
  inc(i)
----

It should be clear that the global variable i resides
in the BSS segment. But what is with the variable j
declared in the body of the while statement? It is
clear that that variable is only visible inside
of the body of the while statement. But does
j reside on a stack? There seems to be no proc involved
so there may be no stack? The variable j may reside in the
BSS segment too? That is not really clear and may be different
for different Nim compilers maybe. But why should we care for
that detail at all? Well it may be important for performance.
Local proc parameters allocated on the stack are generally
optimal for performance, and they are optimized by the compiler very
well. We will learn more about the reasons for that later when we discuss
the data cache. For now we should only remember that it may be
a good idea to avoid global code and put all code in procs. We
may have an arbitrary named main() proc then and call that from
global scope only. At least for the current Nim compiler V 1.2 that
seems to be a good idea, maybe later versions or other implementations
will automatically move all global code into a hidden proc for us.

Let us discuss above while loop again, but this time
in the body of a proc:

----
proc p =
  var i: int
  while i < 100:
    let j: int = i * i
    echo j
    inc(i)
----

When we carefully investigate that proc within the while loop
we may wonder about two points. First we said earlier that we can
and should use the let keyword instead of var when there is 
only one assignment to a variable, so the variable can be 
regarded as immutable. But the loop is executed 100 times,
so how can we say there is only a single assignment to variable j?
The trick is, that j is locally to the while loop, and that j
is virtually new created and initialized to 0 for each iteration.
So let is OK and the compiler does not complain. 

We can test that fact with this simple program:

----
proc main =
  var i: int
  while i < 10:
    var a: int
    a = a + 1
    echo a
    inc(i)
main()
----

The output is 1 for each loop iteration, as variable
a is virtually newly created for each loop iteration.

We said virtually newly created, because we can not be
sure how the compiler may handle it internally. Is storage
for variable a already allocated when the proc is invoked, that is 
in the same way as storage for the loop counter variable i is allocated 
on the stack when the proc is called. Or is storage for variable
a reserved for each loop iteration by increasing the stack pointer at the start
of the loop and resetting it at the end of the loop. We can not be sure without reading
the compiler source code, but finally we should not care, as it does not really matter.

=== Generics

In the previous section we defined a sqr() proc
for ints and one for float numbers. Both procs
look nearly identical, only the data types differ.
For that case we can use so called generic procedures.

----
func sqr[T](v: T): T =
  var p: T
  p = v * v
  return p

echo sqr(2)
echo sqr(3.1415)
----

We put a square bracket after the function name which includes a
symbolic name, and that name is then used instead of concrete
types in the proc header or in the proc body.

We can now call that proc with parameters of different types including
int and float types. You may wonder why that works -- Nim is a statically
typed language, so how can the parameter of function sqr() as well
accept an integer as an float number? Is there a  hidden type conversion
involved? No, the trick is that whenever we call that generic proc with 
a different type, than a new proc or function is instantiated. As we called
the generic sqr() proc with an int and a float parameter, during compile time the
compiler creates machine code for two separate function, one which is
called when an int is passed as parameter, and one which is called when a float
is passed. If we would call that proc name again with an int or float parameter, than
one of the two existing procs would be used. But for a different, still unused
data type like float32 again a new proc would be instantiated. In this way generics
procs can lead to some code bloat. Note that calling the generic function
with a data type like a character or a string would fail, as that
types do not support multiplication with itself.

A slightly different notation is available by so called or types:

----
func sqr(v: int or float): auto =
  var p: typeof(v)
  p = v * v
  return p

echo sqr(2)
echo sqr(3.1415)
----

Here we have limited the parameter types to the int type or the float type.
Again the compiler would instantiate two separate functions for the
both data types. As we had not the symbolic type T available here, we have used the
keyword auto as return type, and for the type of variable p we used the macro
typeof(). The type auto for the return type works as long as the
function returns a well defined type. Note that we can not at runtime decide
what a type the function should return, so a construct like
if cond: return 2 else: return 3.1415 would not work, at least not when the
values are variables of different type. For the literal value it may work, as
the compiler may be smart and guess that we want to return the float literal 2.0.

Generics can become a bit complicated, as we may even use multiple different
generic types for different proc parameters. And we can use generics also
for object types, we may for example create lists like we did for our names
list that work not only for strings, but that can work with other data
types like numbers or sequences in a very similar way. We may explain
that in more detail later.

=== Method call syntax

A useful coding style introduced by OPP languages is the method call
syntax, which was initially used in OOP programming style
for objects, and later applied by languages like Ruby to all
data types. Ruby in some way regards all data as objects.

Method call syntax means, that for example for a variable s of data type string
we do write s.add(c) instead of add(s, c). Or for an integer variable i we may
write i.abs instead of abs(i). That is we put the first parameter of the proc parameter list
in front of the proc name, and separate that parameter from the proc name by a period.
The compiler regards both notation as equivalent. The advantage of the method call
syntax is that we may save a character and that it is more clear with what "object"
we are working, as it stands in front of the expression.

Most OOP languages allows that notation only for a class, for example the string class
may declare all possible operations that can be done with strings, and the
method call syntax is used for that operations. One problem is, that it can
be difficult to add more operations which can be used in that style, as
often all that operations are defined in the class scope. Ruby fixed 
that restriction by allowing so called reopen of classes, that is user can 
later add more operations.

Nim simple allows that notation generally, as did the D language, but D used
the tern [.ndef]#Uniform Function Call Syntax# (UFCS) for it.

=== Procedure variables

Procedures and functions are not always fully static entities.
We can assign procedures and functions to variables, and we
can pass whole procedures or functions as parameters
to other procedures or functions. And functions can even 
generate and return new functions. Let us investigate how
procedure variables work:

----
var
  p: proc(i: int): int

proc p1(i: int): int =
  i + i

proc p2(i: int): int =
  i * i

p = p1
echo p(7)
p = p2
echo p(7)
----

The output of the two echo statements should be 14 and 49 -- we called in both
cases the same proc variable with the same parameter, but the proc variable p
was in the first call an alias for p1, and in the second call an alias for p2.
Note, when we assign a proc to a proc variable we do only write the name of that proc,
there is no () involved. That is because we assign that proc to the proc variable, but we do not call
the proc in this case. Of course, when we assign a proc to a proc variable then the proc signatures
have to match, that is the parameter list and the result have to be compatible.

Now we use a function as a proc argument.

----
type
  EchoProc = proc (x: float)

proc t(ep: EchoProc; x: float) =
  echo "The value is"
  ep(x)


proc ep1(x: float) =
  echo "==> ", x

proc ep2(x: float) =
  echo x

t(ep1, 3.1415)
t(ep2, 3.1415)
----

A common use case for a function as a proc parameter is sorting.
We can use the same sort procedure for different data types
when we provide cmp proc that can compare that data type.

----
from algorithm import sort

proc cmp(a, b: int): int =
  if a < b:
    -1
  elif a == b:
    0
  else:
    1

proc main =
  var a = [2, 3, 1]
  a.sort(cmp)
  for i in a:
    echo i

main()
----

The sort procedure is provided by the algorithm module.
The sort proc accepts an array or a sequence, and a
cmp proc that gets two parameters of the same type as
the elements in the passed array, and that returns
-1, 0, or 1 as the result of the comparison. We could
easily sort other data types like strings or our custom
objects by an arbitrary key, as long as we can provide
a matching cmp() proc. For the cmp proc it is important that it
returns a well defined result based on the input, and when
both parameters are equal it should really return 0. If you would exchange
the return values 1 and -1 in the cmp proc above, you would
invert the sort order.

=== Nested Procedures and Closures

While in C all functions must be defined in top level
scope and nesting of functions is not allowed, in Nim
procedures can contain other procedures. A special case
occurs when the sub-procedures do access variables of the outer
scope. In this case the sub-procedure is called a closure:

----
proc digitScanner(s: string) =

  var pos = 0
  proc nextDigit: char =
    while pos < s.len and s[pos] notin {'0' .. '9'}:
      inc(pos)
    if pos == s.len:
      return '\x0'
    result = s[pos]
    inc(pos)

  var c: char
  while true:
    c = nextDigit()
    if c == '\x0':
      break
    stdout.write(c) 
  stdout.write('\n')

digitScanner("ad5f2eo73q9st")
----

When you run this program the output should be

----
52739
----

This program is not that easy, but when you think about it a bit
you should be able to understand it. The task is to extract
from a string all the digits and to ignore the other characters.

To get the digits, we use a local procedure that uses the pos
variable of the enclosing procedure, and also access the parameter
s of the enclosing procedure. The closure nextDigit() checks if
the position in the string is still valid, that is if it is still
smaller than the length of the string, and also checks if the 
current character is a digit. The first check uses the standard procedure
len() which return the length of a passed string parameter, that is how
many characters the string contains. We have used the method call syntax here instead
using the ordinary proc call len(s). The next check test if the current
character is not  a decimal digit. For that test we could use a series of compares
like if c == '0' or c == '1' or ... or c == '9'. But to make such tests
easier and faster, Nim offers one more data type, the set type. And the notin
operator test if an value is not contained in a set constant. We will
learn more about the set datatype later. An important point for the expression
after the while statement is, that it is processed from left to right.
That fact is here important, because we have first to check if pos
is still a valid position, before we can use the subscript operator []
to access the current character and test if it is not contained in the set.
If the check for the valid position would not come first, then we may
access an invalid position in the string and we would get a runtime range error.

While the position is still valid but the current character is not a digit
we increase the position. The while loop can end by two conditions: Either
the current character is a digit, or we have reached the end of the string
and we have to stop. For the last case we use a special stop mark, we return a
special character which we have entered in  escape notation as '\x0'. That
is a very special character, that is used in C to mark the end of strings.
It is the first character in  the ASCII table and has the decimal value 0.
We said earlier that characters are encoded in 8 bit and correspond to
the unsigned integer numbers 0 up to 255. '\x0' is just a special notation
for the first character which corresponds to integer value 0. We may later say
some more about these magic characters. Well, when the end of the string is reached 
then we return that character. Otherwise we return the current character. Remember,
from the while condition we know  that string end is reached, or current
character is a digit. As we tested for string end before, we can only have the case
that current character is a digit now. But can we return that character
immediately now? If we would, s[pos] would be a digit, and we would
get exactly the same character for the next proc call! So we have to move
to the next character by increasing pos before we return that character.
For this the pre-declared result variable is useful. We assign the current
character to the result variable, and then increase pos. As the last
statement in our proc is not a expression but a plain inc() statement, the content
of the result variable is returned. The other while loop in the outer
procedure is very simple, we just call the closure in the body of the while loop
and terminate the loop when we get the special Null character.

And finally an example where one proc returns
another procedure:

----
proc addN(n: int): auto = (proc(x: int): int = x + n)
 
let add2 = addN(2)
echo add2(7)
----

The output of echo would be 9 in this case. This
construct is sometimes named currying.

=== Converters

Nim's converters are a special variant of functions that are called
automatically by the compiler when argument types do not match.

----
converter myIntToBool(i: int): bool =
  if i == 0:
    false
  else:
    true

proc processBool(b: bool) =
  if b:
    echo "true"
  else:
    echo "false"

var i = 7
processBool(i)
if i:
  echo "true"
else:
  echo "false"
----

With above converter we can pass an integer to a proc that expects a bool
parameter, and we can even use an integer as a logical expression in an
if condition in the same way as it is done in C language.
Converters do work only in a direct way, that is automatic chaining is not supported:
If we have on converter from character to int and one from int to boolean, that
does not mean that we can pass a character to a proc that expects a boolean. We would
have to declare one more converter that directly converts character to bool.

Whenever we do consider using converters we should think twice -- converters
may be confusing, may have some strange effects and may increase compile time.

== Object Orientated Programming and Inheritance

Object Orientated Programming and Inheritance became very popular
in the early nineties of the last century. Java is a prominent
representative of that programming paradigm, but most languages
created in the nineties of the last century support is, like C++,
Ruby and Python.

The idea of OOP is that objects and procedures working on that objects
are grouped to classes, and that classes can be extended with
additional data fields and with additional procedures.
In OOP procedures and function are often called methods and
data fields are called members. Sometimes the members are completely
hidden and are accessed only by so called getter and setter methods.
That is called encapsulation. Encapsulation allows hiding implementation
details, so that that details may change when necessary, without
that the change of internal details become visible to users of that class, so
that the users can use the class without noticing the change.
Getters and setters also help hiding internal details and they
ensure
that the class is always in a consistent and valid state.

An important property of OOP is dynamic dispatch: When we create
various sub-classes of a common parent class, and we have defined methods
for all the sub-classes, then we can have collections of instances of different
sub-classes, and the compiler can automatically ensure that always 
the matching method for each instance is called.

A classical example is a drawing program, where we have different geometrical shapes
like rectangle, circle and many more. All the geometrical objects
are stored is some form of list, and when we want to draw all of them
on the screen then we have to call only a unspecific draw() method, and
the compiler ensures that for each shape the matching draw method
is called. In Nim that may look like

----
type
  Shape = ref object of RootRef

  Rectangle = ref object of Shape
    x, y, width, height: float

  Circle = ref object of Shape
    x, y, radius: float

  LineSegment = ref object of Shape
    x1, y1, x2, y2: float

method draw(s: Shape) {.base.} =
  # override this base method
  quit "to override!"

method draw(r: Rectangle) =
  echo "drawing a rectangle"

method draw(r: Circle) =
  echo "drawing a circle"

method draw(r: LineSegment) =
  echo "drawing a line segment"

proc main =
  var l: seq[Shape]
  l.add(Rectangle(x: 0, y: 0, width: 100, height: 50))
  l.add(Circle(x: 60, y: 20, radius: 50))
  l.add(LineSegment(x1: 20, y1: 20, x2: 50, y2: 50))

  for el in l:
    draw(el)

main()
----

The output of that program is

----
drawing a rectangle
drawing a circle
drawing a line segment
----

So we can have a sequence of the base type, add various sub-types
and then iterate over the list to draw all the various sub-types.
Of course in the same way we could do many more task like
moving, rotating or storing all the objects in one call. The
compiler does the right dynamic dispatching for us, we have just
to provide all necessary methods. The need of the base method
seems to be a bit strange, some other OOP languages do not need that.
The base method is marked by a {.base.} pragma, we will discuss
the purpose of pragmas later. In the example we have used only one
level of sub-classing, but of course we can use many levels, for example
we can again subclass the Circle by a FilledCircle with a color field.

The OOP coding style can be very convenient for some task, one
important use case could be graphical user interfaces where
the graphical elements like labels, buttons, frames built
in natural way a hierarchical structure. Another typical 
use case are drawing applications with code similar to our basic example.

Not that the OOP style only works with ref objects, but not with value objects.
The obvious reason is that we can have collections of different
sub-types stored in arrays or seqences only for ref objects, as
in arrays and sequences all element types have to have equal size. For references
that it the case, as references are basically pointers. But different
value types would have different size. Linked lists would be no better
solution, as again we can not built lists with value objects.

For maximum performance OOP code with ref objects is generally not optimal, as
the dispatching itself needs some time, and as the ref objects
are not contained in a single block of memory, but are distributed
in the whole RAM, which is not cache friendly.

== Other builtin Data Types

=== Tuples

Tuples can be regarded as some form of lightweight objects without
inheritance support, but mostly tuples are used when
functions has to return multiple arguments.

----
type
  Move = tuple
    from: int
    to: int
    check: bool

proc findBestNextMove(): (dest: int; check: bool) =
  ...

let (dst, check) = findBestNextMove()
----

Here we define a custom Move type similar as we would do for
a custom object, but we do not use that type at all but
return an anonymous tuple from our proc, that is a pair of
an int and a bool.

Due to type inference our dst and check variables gets
the data types int and bool.

Tuples are also useful when a function has to return a value and
also an error state, or if it may not be able to return something
at all in a special case. For references we could return nil then, but
for results like int or float we may not have a well defined error
indicating constant, so we can return a tuple with an additional bool.
But we could use exceptions instead, or we could use Nim's option type
instead. We will learn more about that later.

=== Enums

While enums in C are nothing more than integers with some special
syntax for creation, Nims enums are more complex.

In Nim enums can be used whenever some form of symbols are needed
like the colors red, yellow and green of a traffic light or
the directions north, south, east and west for a map or a game.

Most of the time we declare an enum type and the corresponding
values by simple listing them like 

----
type
  TrafficLight = enum
    red, yellow, green
----

We can use variables of type TrafficLight then like

----
var tl: TrafficLight
tl = green
if tl == red:
  tl = ...
----

Enums support assignment, plain tests for (in)-equality and for smaller or greater.
Additional the functions succ() and pred() are defined for enums to get
the successor or predecessor of an enum, ord() or int() deliver the corresponding integer number
and the $ operator can be used
to get the name of an enum. We can also iterate over enums, so we can
print all the colors of our  TrafficLight by

----
for el in TrafficLight
  echo el.ord, ' ', $el
----

Ordinary enums start at 0 and uses continues numbers for the internal
numeric value, so that enums can be used as array indices.
But we can also assign custom numbers like

----
type
  TrafficLigth = enum
    red = -1, yello = 3, green = 8
----

We should avoid that, as these "enums with holes" generate some problems for
the compiler and may be later deprecated. For example array indexing or iterating
is obviously not possible for enums with holes.

It is also possible to set the string that the stringify operator $ returns, like
in 

----
type
  TrafficLigth = enum
    red = "Stop"
    yellow = (2, "Caution")
    green = ("Go")
----

Here the assigned numerical values should be 0, 2 and 3. Currently the enums values
must be specified in ascending order always.

When we have many enums in a program then name conflicts may occur, for example
we may have an addition enum type named BaseColor which also has red and green
members. For that case the {.pure.} pragma exists:

----
type
  BaseColor {.pure.} = enum
    red, green, blue
----

With the pure pragma applied we can use the full qualified
enum name when necessary, like BaseColor.red. But
we can still
use unqualified names like blue when there is no name conflict.

=== Sets

From mathematics we know that sets are some form of unordered collection
for which we can test membership (x is included in mySet) and we
can perform general set operations like union of multiple sets.

The set data type maps well to bit operations of the CPU, as
the CPU can generally clear, set and test single bits and perform
logical operations of words -- remember a logical or operation
sets all the bits in destination operand for which at least one source
operand had a bit set.

A prominent example for use of sets is the set of ASCII characters.

----
type
  CharSet = set[char]
var s = {'a' .. 'z', '.', ',', '!', '?'} 
var c: char
if c in s:
  doSomething()
----

Here we tested if c is a lowercase letter or one of the 4 common
punctuation characters. In Nim we can use the range notation ..
to specify ranges, here that is the sequence of all lowercase
letter. It works in this case only, as we know that all
lowercase letters built an uninterrupted range in the ASCII
table. We used the in operator to test if c is one of the
listed set character literals.

A character set needs 256 bits for its representation, as we have
256 characters in the ASCII table and a character is one byte in size
so it can store each of the ASCII characters. On a 64 bit computer
256 bits takes 4 words, so above in test would need at most
4 CPU instructions with bit tests. That is a fast operation, faster
compared to many or test, and the set notation is easier to write.

In Nim we can also use sets for the int8 or int16 type, but not for
data types with more than 16 bit. A set with a 16 bit base datatype
would already need 2^16 bit, that is 2^13 = 8096 bytes or 1024 words
on a 64 bit CPU. That is the in test from above would extend
to 1024 word tests for a set with 16 bit base type like a int16.

Beside in or notin test we can join sets with the + operator and
do all the ordinary operations on sets that are common in math.

=== Object Variants

Nim's object variants, sometimes also called sum types or abstract data types (ADT), are an
advanced and type save variant of the union type known from C.
The basic idea is that we may use value types that may
store similar, but not identical data. Untyped languages
like Ruby or Python allow that of course, and we can do
it in Nim with ref types and inheritance too, as we showed in a previous
section with our Shape base type and various geometric shapes.
We could store that ref types in arrays or sequences or linked
list and use dynamic dispatch for processing the various sub-types.
That is convenient but gives not maximum performance due
to dynamic dispatch at runtime and due to bad cache use.
So we may like to have a value type with different content, so
that we can store all the value types in a seq and all
entities reside in a compact block of memory for good cache use.

----
type
  ShapeKind = enum
    line, rect, circ

  Shape = object
    visible: bool
    case kind: ShapeKind
    of line:
      x1, y1, x2, y2: float
    of rect:
      x, y, width, height: float
    of circ:
      x0, y0, radius: float

proc draw(el: Shape) =
  if el.kind == line:
    echo "process line segment"
  elif el.kind == rect:
    echo "process rectangle"
  elif el.kind == circ:
    echo "process circle"
  else:
    echo "unknown shape"

var
  s: seq[Shape]
s.add(Shape(kind: circ, x0: 0, y0:0, radius: 100, visible: true))
for el in s:
  draw(el)
----

Objects variants can have common fields like the boolean state visible above,
but the other fields are not allowed to use the same names, so we
had to use x0 and y0 for the names of the center coordinates in the cycle variant.

As you can see we can store all the different object variants as value objects
in a sequence and iterate over it. Note that object variants may waste some
storage, as all variants are silently enlarged to have the exact same size, so
that all variant types can be stored in an array or sequences and can be passed as
proc parameters in the same way to the same proc. 

== Iterators

We have already used some of Nim's standard iterators to iterate over the
characters of a string or the content of a sequence. Declaring
iterators is similar to declaring procedures, but we use the yield
keyword to return a single value back to the caller of the iterator.
When the body of the iterator declaration is reached the iterator terminates.
In an earlier section we declared a procedure that extracted the decimal
digits from a string. We can do the same with a iterator:

----
iterator decDigits(s: string) =
  var pos = 0
  while pos < s.len and s[pos] notin {'0' .. '9'}:
    inc(pos)
  if pos < s.len:
    inc(pos)
    yield(s[pos - 1])

for d in decDigits("df4j6dr78sd31tz"):
  stdout.write(d)
stdout.write('\n')
----

Nim supports closure-iterators and inline-iterators. The later
have to be marked with the {.inline.} pragma in the header of the declaration.
Inline-iterators are inserted like templates at the location where they are
called and offer maximum performance, but each call increases the total
code size. Closure iterators are invoked like ordinary procedures, the
invocation eats some performance. Note: Iterators do not provide
a predefined result variable as procedures do. To avoid the need of
declaring a res variable of type character, in above code we increase pos
by one first and yield s[pos - 1].

== Templates

Nim templates are a more powerful variant of the macros in C.
While in C macros are processed by the pre-processor and 
are mostly just a plain text substitution, in Nim
templates are a fundamental part of the languages and
can be used in a similar way like procedures.
But while procedures built a single block of code
that is then called multiple times, templates work
like C macros as textual substitution. Wherever we call
a template the template source code is inserted.

----
template sqr(i: int): int =
  i * i

var j: 7
echo sqr(j)
----

== Casts and type Conversion

While we have various types of casts in C++, we have only one cast
and type conversions in Nim. In Nim casts just reinterpret the same
bit pattern for another data type. For example the boolean value false
is internally encoded as a byte with all bits cleared, and true is encoded
as a byte with all bit but the least significant one cleared. We could 
cast a bool to an int8 of same size and would get a decimal number 0 or 1.
Casting is not a real operation at all, as nothing is really done. We watch the
same bit pattern just from a different perspective. But casting is dangerous,
it violates the safe type system of the language, and it can go very wrong:
Can we cast between float64 and int64? Well they have same size, and both are numbers.
We can cast, but the result would be far away from what we may expect. While 
int64 has the well known and simple value encoding, that is rightmost bit stands
for 2^0, next bit for 2^1 and so far, the encoding of floats is much more
difficult and has not such a simple scheme. In floats some bits represent the so called mantissa
and some bits represent the exponent. When we cast we may again get a number, but
the value is not really predictable.
We have to be very carefully when we cast between types of different size. Nim may permit that
but we have to think what may really happen. When we cast between a bool and a int64, in one direction
7 bytes have to be ignored, and in the other direction for 7 missing bytes there is some
padding necessary. We do a cast by writing after the keyword cast in square brackets the
desired type followed by parenthesis enclosing the source variable:

----
var i: uint8 = cast[unint8](myBoolVar)
----

Totally different to casting is type conversion. We can convert integers to floats
without problem, for the conversion we use the type like a proc call, that is int(myfloat)
or float(myInt) -- of course we could use method call syntax like myInt.float instead.
Type conversion is some effort for the CPU, but most advanced CPU's should have fast
instructions for basic conversion.

Nim generally only allows type conversions that involve not too much effort.
So we should not expect var i ="1234"; echo i.int * 7 to be available. Such a conversion
is expensive, at runtime it costs many CPU cycles as we would have to extract the digits, multiply
with it weight and sum then up. So for that operation functions like parseInt() are available
that accept a string as argument and return an int. There exists different variants of parseInt(),
one may raise exceptions for invalid input, the other may return a boolean.
 
== Exceptions

When we execute our code, sometimes something can go wrong: We may have an
unexpected division by zero or an overflow, or we get some invalid user input.
There exists various strategies to handle such situations. One is to terminate our program,
we may do that by a plain assert() or quit() statements. If we have absolutely no
idea how to recover from an error then that may be our best option. The user
may restart the program, or the program may be restarted by some sort of supervisor
program. For more expectable errors some sort of error indicator may be a better
solution, for example a parseInt() procedure may return a boolean value for
success. As we have to return the result for success also, the 
parseInt() proc may return a tuple, or may get a var parameter in which the result
is returned. Another solutions are exceptions as known from C++.

----
proc charToInt(c: char): int =
  if c in {'0' .. '9'}:
    return ord(c) - ord('0')
  raise newException(OSError, "parse error")

proc main =
  while true:
    stdout.write("Please enter a single decimal digit: ")
    let s = stdin.readline
    try:
      echo "Fine, the number is: ", charToInt(s[0])
    except:
      if s.len == 0:
        break
      echo "Try again"

main()
----

This section has to be extended...

== Modules

Modules are Nim's way to divide multiple source codes in clearly
separated units and to hide implementation details. Nim use a module concept which is very similar
to Modula-2 or Oberon. All the Nim standard libraries are divided into
modules which collect and logically group data types and the related 
procedures. In some way modules are Nim's classes.

In Nim each module directly corresponds to one text file. Sub-modules
as known from Ruby, that divide a single text file in multiple modules are
not supported by Nim currently.

Every textfile with Nim source code is basically a module, and that module
can be imported and used by other modules. But all symbols like 
data types or procedures have to be exported to make them visible and usable
by other modules. That is done like in Oberon by appending an asterisk 
character to all names that should be exported. These restricted
exports allows to hide implementation details -- all symbols
not exported are private to that module and can at be changed and improved 
at any time without noticing the importing module.

We can import whole modules, that is all symbols that are marked for
export by the asterisk, or we can import only the symbols that we need
by specifying their names. Let us create a module that declares a
single procedure to remove all characters from a string that are not
letters:

----
# save this textfile with name mystrops.nim
proc remNoneLetters*(s: string): string =
  result = newString(s.len)
  for c in s:
    if c in {'a' .. 'z', 'A' .. 'Z'}:
      result[pos] = c
      inc(pos)
  result.setLen(pos)
----

We save above text file with our Nim source code with
name mystrops.nim and can import it like

----
import mystrops

echo remNoneLetters("3h7.5g:8h")
----

Module names should be lower case and may as other Nim symbols only contain
letters and the underscore character.  

Note the export marker after the proc name. Instead
of importing whole modules we can import only single symbols
with the from x import y, z syntax like

----
from mystrops import remNoneLetters

echo remNoneLetters("3h7.5g:8h")
----

Both forms are an unqualified import, that is we can
refer to the proc by only its name, we do not need
the qualified form with module name prefix like
mystrops.remNoneLetters() as long as there are no name conflicts.
But whenever we want we can use the qualified form also.

Nim programmer generally prefer importing whole modules and
use unqualified names, while
that is considered bad style in some other languages like Python.
In untyped languages like Python unqualified imports
may indeed pollute the name space and generate many name
conflicts, but in statically typed languages like Nim
unqualified import seems to generate name conflicts
only in very rare cases. Procedures with the same
name generally have different parameter list, so
the overload resolution of the compiler can decide
what proc is to be used. And when really a name conflict
occurs then the compiler will tell us, and we can easily fix
it by prefixing the proc name with its module name.

For data types, constants or enums chances for name conflicts
may be not that tiny, so we may have to use qualified names.

We can also enforce a fully qualified import in Nim by a notation like

----
from mystrops import nil
----

In this case we can use all symbols from that module only in qualified form.
But that does not always work that well in Nim, as Nim has not classes like
Java, so a qualified use of method call syntax or qualified use of user defined or overloaded operators
is difficult.
Imagine strutils.add(s, '\n'), how should that look with method call syntax?

For imports we have also the except keyword, so we may do something like

----
import strutils except toUpper
----

The except keyword can be used to prevent possible name conflicts
without having to use qualified names.

Note that the system module is imported automatically, we should not import
it directly. Also note that Nim always imports only what is really needed
in the final executable, so importing only a few symbols from a module
has no code size benefit over importing the whole module. Still
it may improve readability of your code when you import only single
symbols when you are sure that you need not more. Maybe like from
math import Pi. Note that you can even in that case access other
symbols of that module by fully qualified names like math.sin().

With the growing standard library it may occur that module 
names of the standard library interfere with your own module names.
So Nim now allows and recommends qualified import of modules
from the standard library like import std/strutils. And
for external packages installed by the nimble package manager
imports in the form import package/[mod1, mod2, mod3] are permitted. 

== Include

The include statement should be not confused with the import statement.
Include just insert a textfile at the position where the include
statement occurs. Include can be used to split very large modules
in smaller entities.


= Part III: The standard library

== Standard Container

= Part IV: External packages

== xxx

xxx

= Part V: Advanced topics

== Macros

== Async

== Parallel Processing

== FFI

== Concepts

= Part VI: Advanced examples

== something

= Appendix

== ASCII Table

----
proc print(i: int) =
  let c =
    if i > 31 and i < 128: char(i) else: ' '
  stdout.write("  ", c, "  ")

proc main =
  echo "Visible ASCII Characters\n"
  stdout.write("     ")
  for i in 0 .. 15:
    if i < 10:
       stdout.write(" +")
    else:
      stdout.write("+")
    stdout.write(i, "  ")
  stdout.write('\n')
  var i = 0
  while i < 128:
    if i < 10:
      stdout.write("  ")
    elif i < 100:
      stdout.write(" ")
    stdout.write(i, ' ')
    for j in 0 .. 15:
      print(i + j)
    stdout.write('\n')
    inc(i, 16)

main()
----
